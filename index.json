[{"content":"\n\n- [JSON是一种格式，基于文本，优于轻量，用于交换数据](#JSON是一种格式，基于文本，优于轻量，用于交换数据)\n    - [一种数据格式](#一种数据格式)\n    - [基于文本的数据格式](#基于文本的数据格式)\n    - [轻量级的数据格式](#轻量级的数据格式)\n    - [被广泛地用于数据交换](#被广泛地用于数据交换)\n- [JSON和JS对象的区别](#JSON和JS对象的区别)\n    - [两个本质不同的东西为什么那么密切](#两个本质不同的东西为什么那么密切)\n    - [JSON格式区别JS对象语法表现上严格在哪](#JSON格式区别JS对象语法表现上严格在哪)\n    - [JSON不是JS的子集](#JSON不是JS的子集)\n- [JSON相关函数具体的执行细节](#JSON相关函数具体的执行细节)\n\n先来看一个JS中常见的JS对象序列化成JSON字符串的问题，请问，以下JS对象通过JSON.stringify后的字符串是怎样的？\n\n```\nvar friend={  \n    firstName: 'Good',\n    'lastName': 'Man',\n    'address': undefined,\n    'phone': [\"1234567\",undefined],\n    'fullName': function(){\n        return this.firstName + ' ' + this.lastName;\n    }\n};\nJSON.stringify(friend);//这一行返回什么呢？ \n```\n\n第二个问题，如果我想在最终JSON字符串将这个'friend'的姓名全部变成大写字母，也就是把\"Good\"变成\"GOOD\"，把\"Man\"变成\"MAN\"，那么可以怎么做？\n\n基于以上两个问题，我们再追本溯源问一下，JSON究竟是什么东西？为什么JSON就是易于数据交换？JSON和JS对象的区别？JS中JSON.parse、JSON.stringify和不常见的toJSON，这几个函数的参数和处理细节到底是怎样的？\n\n下文将从以下几个方面去理解JSON：\n\n首先是对“JSON是一种轻量的数据交换格式”的理解；\n\n然后来看经常被混为一谈的JSON和JS对象的区别；\n\n最后我们再来看JS中这几个JSON相关函数具体的执行细节。\n\n### 一、JSON是一种格式，基于文本，优于轻量，用于交换数据\n\n如果没有去过JSON的官方介绍可以去一下，官方介绍第一、二段已经很清楚地表述了JSON是什么，我将JSON是什么提炼成以下几个方面：\n\n1. 一种数据格式\n\n什么是格式？就是规范你的数据要怎么表示，举个例子，有个人叫“二百六”，身高“160cm”，体重“60kg”，现在你要将这个人的这些信息传给别人或者别的什么东西，你有很多种选择：\n\n```\n姓名“二百六”，身高“160cm”，体重“60kg”\n\nname=\"二百六\"\u0026height=\"160cm\"\u0026weight=\"60kg\"\n\n\u003cperson\u003e\u003cname\u003e二百六\u003c/name\u003e\u003cheight\u003e160\u003c/height\u003e\u003cweight\u003e60\u003c/weight\u003e\u003c/person\u003e\n\n{\"name\":\"二百六\",\"height\":160,\"weight\":60}\n\n... ...\n\n```\n\n以上所有选择，传递的数据是一样的，但是你可以看到形式是可以各式各样的，这就是各种不同格式化后的数据，JSON是其中一种表示方式。\n\n2. 基于文本的数据格式\n\nJSON是基于文本的数据格式，相对于基于二进制的数据，所以JSON在传递的时候是传递符合JSON这种格式的字符串，我们常会称为“JSON字符串”。\n\n3. 轻量级的数据格式\n\n在JSON之前，有一个数据格式叫xml，现在还是广泛在用，但是JSON更加轻量，如xml需要用到很多标签，像上面的例子中，你可以明显看到xml格式的数据中标签本身占据了很多空间，而JSON比较轻量，即相同数据，以JSON的格式占据的带宽更小，这在有大量数据请求和传递的情况下是有明显优势的。\n\n4. 被广泛地用于数据交换\n\n轻量已经是一个用于数据交换的优势了，但更重要的JSON是易于阅读、编写和机器解析的，即这个JSON对人和机器都是友好的，而且又轻，独立于语言（因为是基于文本的），所以JSON被广泛用于数据交换。\n\n以前端JS进行ajax的POST请求为例，后端PHP处理请求为例：\n\n前端构造一个JS对象，用于包装要传递的数据，然后将JS对象转化为JSON字符串，再发送请求到后端；\n\n后端PHP接收到这个JSON字符串，将JSON字符串转化为PHP对象，然后处理请求。\n\n可以看到，相同的数据在这里有3种不同的表现形式，分别是前端的JS对象、传输的JSON字符串、后端的PHP对象，JS对象和PHP对象明显不是一个东西，但是由于大家用的都是JSON来传递数据，大家都能理解这种数据格式，都能把JSON这种数据格式很容易地转化为自己能理解的数据结构，这就方便了，在其他各种语言环境中交换数据都是如此。\n\n### 二、JSON和JS对象的区别\n\n很多时候都听到“JSON是JS的一个子集”这句话，而且这句话我曾经也一直这么认为，每个符合JSON格式的字符串你解析成js都是可以的，直到后来发现了一个奇怪的东西...\n\n1. 两个本质不同的东西为什么那么密切\n\nJSON和JS对象本质上完全不是同一个东西，就像“斑马线”和“斑马”，“斑马线”基于“斑马”身上的条纹来呈现和命名，但是斑马是活的，斑马线是非生物。\n\n同样，\"JSON\"全名\"JavaScript Object Notation\"，所以它的格式（语法）是基于JS的，但它就是一种格式，而JS对象是一个实例，是存在于内存的一个东西。\n\n说句玩笑话，如果JSON是基于PHP的，可能就叫PON了，形式可能就是这样的了['propertyOne' =\u003e 'foo', 'propertyTwo' =\u003e 42,]，如果这样，那么JSON可能现在是和PHP比较密切了。\n\n此外，JSON是可以传输的，因为它是文本格式，但是JS对象是没办法传输的，在语法上，JSON也会更加严格，但是JS对象就很松了。\n\n那么两个不同的东西为什么那么密切，因为JSON毕竟是从JS中演变出来的，语法相近。\n\n2. JSON格式区别JS对象语法表现上严格在哪\n\n先就以“键值对为表现的对象”形式上，对比下两者的不同，至于JSON还能以怎样的形式表现，对比完后再罗列。\n\n\n![](./images/json.jpg)\n\n\n可以看到，相对于JS对象，JSON的格式更严格，所以大部分写的JS对象是不符合JSON的格式的。\n\n以下代码引用自这里\n\n```\nvar obj1 = {}; // 这只是 JS 对象\n\n// 可把这个称做：JSON 格式的 JavaScript 对象 \nvar obj2 = {\"width\":100,\"height\":200,\"name\":\"rose\"};\n\n// 可把这个称做：JSON 格式的字符串\nvar str1 = '{\"width\":100,\"height\":200,\"name\":\"rose\"}';\n\n// 这个可叫 JSON 格式的数组，是 JSON 的稍复杂一点的形式\nvar arr = [  \n    {\"width\":100,\"height\":200,\"name\":\"rose\"},\n    {\"width\":100,\"height\":200,\"name\":\"rose\"},\n    {\"width\":100,\"height\":200,\"name\":\"rose\"},\n];\n\n// 这个可叫稍复杂一点的 JSON 格式的字符串     \nvar str2='['+  \n    '{\"width\":100,\"height\":200,\"name\":\"rose\"},'+\n    '{\"width\":100,\"height\":200,\"name\":\"rose\"},'+\n    '{\"width\":100,\"height\":200,\"name\":\"rose\"},'+\n']';  \n```\n\n另外，除了常见的“正常的”JSON格式，要么表现为一个对象形式{...}，要么表现为一个数组形式[...]，任何单独的一个10进制数值、双引号字符串、布尔值和null都是有效符合JSON格式的。\n\n3. JSON不是JS的子集\n\n首先看下面的代码：\n\n```\nvar code = '\"\\u2028\\u2029\"';  \nJSON.parse(code); // works fine  \neval(code); // fails  \n```\n\n这两个字符\\u2028和\\u2029分别表示行分隔符和段落分隔符，JSON.parse可以正常解析，但是当做js解析时会报错。\n\n### 三、JSON相关函数具体的执行细节\n\n在JS中我们主要会接触到两个和JSON相关的函数，分别用于JSON字符串和JS数据结构之间的转化，一个叫JSON.stringify，它很聪明，聪明到你写的不符合JSON格式的JS对象都能帮你处理成符合JSON格式的字符串，所以你得知道它到底干了什么，免得它只是自作聪明，然后让你Debug long time；另一个叫JSON.parse，用于转化json字符串到JS数据结构，它很严格，你的JSON字符串如果构造地不对，是没办法解析的。\n\n而它们的参数不止一个，虽然我们经常用的时候只传入一个参数。\n\n此外，还有一个toJSON函数，我们较少看到，但是它会影响JSON.stringify。\n\n1. 将JS数据结构转化为JSON字符串——JSON.stringify\n\n这个函数的函数签名是这样的：\n\n```\nJSON.stringify(value[, replacer [, space]]) \n```\n\n下面将分别展开带1~3个参数的用法，最后是它在序列化时做的一些“聪明”的事，要特别注意。\n\n1.1 基本使用——仅需一个参数\n\n这个大家都会使用，传入一个JSON格式的JS对象或者数组，JSON.stringify({\"name\":\"Good Man\",\"age\":18})返回一个字符串\"{\"name\":\"Good Man\",\"age\":18}\"。\n\n可以看到本身我们传入的这个JS对象就是符合JSON格式的，用的双引号，也没有JSON不接受的属性值，那么如果像开头那个例子中的一样，how to play？不急，我们先举简单的例子来说明这个函数的几个参数的意义，再来说这个问题。\n\n1.2 第二个参数可以是函数，也可以是一个数组\n\n如果第二个参数是一个函数，那么序列化过程中的每个属性都会被这个函数转化和处理\n\n如果第二个参数是一个数组，那么只有包含在这个数组中的属性才会被序列化到最终的JSON字符串中\n\n如果第二个参数是null，那作用上和空着没啥区别，但是不想设置第二个参数，只是想设置第三个参数的时候，就可以设置第二个参数为null\n\n这第二个参数若是函数\n\n```\nvar friend={  \n    \"firstName\": \"Good\",\n    \"lastName\": \"Man\",\n    \"phone\":\"1234567\",\n    \"age\":18\n};\n\nvar friendAfter=JSON.stringify(friend,function(key,value){  \n    if(key===\"phone\")\n        return \"(000)\"+value;\n    else if(typeof value === \"number\")\n        return value + 10;\n    else\n        return value; //如果你把这个else分句删除，那么结果会是undefined\n});\n\nconsole.log(friendAfter);  \n//输出：{\"firstName\":\"Good\",\"lastName\":\"Man\",\"phone\":\"(000)1234567\",\"age\":28}\n```\n\n如果制定了第二个参数是函数，那么这个函数必须对每一项都有返回，这个函数接受两个参数，一个键名，一个是属性值，函数必须针对每一个原来的属性值都要有新属性值的返回。\n\n那么问题来了，如果传入的不是键值对的对象形式，而是方括号的数组形式呢？，比如上面的friend变成这样：friend=[\"Jack\",\"Rose\"]，那么这个逐属性处理的函数接收到的key和value又是什么？如果是数组形式，那么key是索引，而value是这个数组项，你可以在控制台在这个函数内部打印出来这个key和value验证。\n\n这第二个参数若是数组\n\n```\nvar friend={  \n    \"firstName\": \"Good\",\n    \"lastName\": \"Man\",\n    \"phone\":\"1234567\",\n    \"age\":18\n};\n\n//注意下面的数组有一个值并不是上面对象的任何一个属性名\nvar friendAfter=JSON.stringify(friend,[\"firstName\",\"address\",\"phone\"]);\n\nconsole.log(friendAfter);  \n//{\"firstName\":\"Good\",\"phone\":\"1234567\"}\n//指定的“address”由于没有在原来的对象中找到而被忽略\n```\n\n如果第二个参数是一个数组，那么只有在数组中出现的属性才会被序列化进结果字符串，只要在这个提供的数组中找不到的属性就不会被包含进去，而这个数组中存在但是源JS对象中不存在的属性会被忽略，不会报错。\n\n1.3 第三个参数用于美化输出——不建议用\n\n指定缩进用的空白字符，可以取以下几个值：\n\n是1-10的某个数字，代表用几个空白字符\n\n是字符串的话，就用该字符串代替空格，最多取这个字符串的前10个字符\n\n没有提供该参数 等于 设置成null 等于 设置一个小于 1 的数\n\n```\nvar friend={  \n    \"firstName\": \"Good\",\n    \"lastName\": \"Man\",\n    \"phone\":{\"home\":\"1234567\",\"work\":\"7654321\"}\n};\n\n//直接转化是这样的：\n//{\"firstName\":\"Good\",\"lastName\":\"Man\",\"phone\":{\"home\":\"1234567\",\"work\":\"7654321\"}}\n\nvar friendAfter=JSON.stringify(friend,null,4);  \nconsole.log(friendAfter);  \n/*\n{\n    \"firstName\": \"Good\",\n    \"lastName\": \"Man\",\n    \"phone\": {\n        \"home\": \"1234567\",\n        \"work\": \"7654321\"\n    }\n}\n*/\n\nvar friendAfter=JSON.stringify(friend,null,\"HAHAHAHA\");  \nconsole.log(friendAfter);  \n/*\n{\nHAHAHAHA\"firstName\": \"Good\",  \nHAHAHAHA\"lastName\": \"Man\",  \nHAHAHAHA\"phone\": {  \nHAHAHAHAHAHAHAHA\"home\": \"1234567\",  \nHAHAHAHAHAHAHAHA\"work\": \"7654321\"  \nHAHAHAHA}  \n}\n*/\n\nvar friendAfter=JSON.stringify(friend,null,\"WhatAreYouDoingNow\");  \nconsole.log(friendAfter);  \n/* 最多只取10个字符\n{\nWhatAreYou\"firstName\": \"Good\",  \nWhatAreYou\"lastName\": \"Man\",  \nWhatAreYou\"phone\": {  \nWhatAreYouWhatAreYou\"home\": \"1234567\",  \nWhatAreYouWhatAreYou\"work\": \"7654321\"  \nWhatAreYou}  \n}\n*/\n```\n\n序列化是为了传输，传输就是能越小越好，加莫名其妙的缩进符，解析困难（如果是字符串的话），也弱化了轻量化这个特点。\n\n1.4 注意这个函数的“小聪明”（重要）\n\n如果有其他不确定的情况，那么最好的办法就是\"Have a try\"，控制台做下实验就明了。\n\n键名不是双引号的（包括没有引号或者是单引号），会自动变成双引号；字符串是单引号的，会自动变成双引号\n\n最后一个属性后面有逗号的，会被自动去掉\n\n非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中 这个好理解，也就是对非数组对象在最终字符串中不保证属性顺序和原来一致\n\n布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值 \n\n也就是你的什么new String(\"bala\")会变成\"bala\"，new Number(2017)会变成2017\n\nundefined、任意的函数（其实有个函数会发生神奇的事，后面会说）以及 symbol 值（symbol详见ES6对symbol的介绍）\n\n出现在非数组对象的属性值中：在序列化过程中会被忽略\n\n出现在数组中时：被转换成 null\n\n```\nJSON.stringify({x: undefined, y: function(){return 1;}, z: Symbol(\"\")});  \n//出现在非数组对象的属性值中被忽略：\"{}\"\nJSON.stringify([undefined, Object, Symbol(\"\")]);  \n//出现在数组对象的属性值中，变成null：\"[null,null,null]\"\nNaN、Infinity和-Infinity，不论在数组还是非数组的对象中，都被转化为null\n```\n\n所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们\n\n不可枚举的属性会被忽略\n\n2. 将JSON字符串解析为JS数据结构——JSON.parse\n\n这个函数的函数签名是这样的：\n\n```\nJSON.parse(text[, reviver])  \n```\n\n如果第一个参数，即JSON字符串不是合法的字符串的话，那么这个函数会抛出错误，所以如果你在写一个后端返回JSON字符串的脚本，最好调用语言本身的JSON字符串相关序列化函数，而如果是自己去拼接实现的序列化字符串，那么就尤其要注意序列化后的字符串是否是合法的，合法指这个JSON字符串完全符合JSON要求的严格格式。\n\n值得注意的是这里有一个可选的第二个参数，这个参数必须是一个函数，这个函数作用在属性已经被解析但是还没返回前，将属性处理后再返回。\n\n```\nvar friend={  \n    \"firstName\": \"Good\",\n    \"lastName\": \"Man\",\n    \"phone\":{\"home\":\"1234567\",\"work\":[\"7654321\",\"999000\"]}\n};\n\n//我们先将其序列化\nvar friendAfter=JSON.stringify(friend);  \n//'{\"firstName\":\"Good\",\"lastName\":\"Man\",\"phone\":{\"home\":\"1234567\",\"work\":[\"7654321\",\"999000\"]}}'\n\n//再将其解析出来，在第二个参数的函数中打印出key和value\nJSON.parse(friendAfter,function(k,v){  \n    console.log(k);\n    console.log(v);\n    console.log(\"----\");\n});\n/*\nfirstName  \nGood  \n----\nlastName  \nMan  \n----\nhome  \n1234567  \n----\n0  \n7654321  \n----\n1  \n999000  \n----\nwork  \n[]\n----\nphone  \nObject  \n----\n\nObject  \n----\n*/\n```\n\n仔细看一下这些输出，可以发现这个遍历是由内而外的，可能由内而外这个词大家会误解，最里层是内部数组里的两个值啊，但是输出是从第一个属性开始的，怎么就是由内而外的呢？\n\n这个由内而外指的是对于复合属性来说的，通俗地讲，遍历的时候，从头到尾进行遍历，如果是简单属性值（数值、字符串、布尔值和null），那么直接遍历完成，如果是遇到属性值是对象或者数组形式的，那么暂停，先遍历这个子JSON，而遍历的原则也是一样的，等这个复合属性遍历完成，那么再完成对这个属性的遍历返回。\n\n本质上，这就是一个深度优先的遍历。\n\n有两点需要注意：\n\n如果 reviver 返回 undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值。\n\n你可以注意到上面例子最后一组输出看上去没有key，其实这个key是一个空字符串，而最后的object是最后解析完成对象，因为到了最上层，已经没有真正的属性了。\n\n3. 影响 JSON.stringify 的神奇函数——object.toJSON\n\n如果你在一个JS对象上实现了toJSON方法，那么调用JSON.stringify去序列化这个JS对象时，JSON.stringify会把这个对象的toJSON方法返回的值作为参数去进行序列化。\n\n```\nvar info={  \n    \"msg\":\"I Love You\",\n    \"toJSON\":function(){\n        var replaceMsg=new Object();\n        replaceMsg[\"msg\"]=\"Go Die\";\n        return replaceMsg;\n    }\n};\n\nJSON.stringify(info);  \n//出事了，返回的是：'\"{\"msg\":\"Go Die\"}\"',说好的忽略函数呢\n```\n\n这个函数就是这样子的。\n\n其实Date类型可以直接传给JSON.stringify做参数，其中的道理就是，Date类型内置了toJSON方法。\n\n四、小结以及关于兼容性的问题\n\n到这里终于把，JSON和JS中的JSON，梳理了一遍，也对里面的细节和注意点进行了一次遍历，知道JSON是一种语法上衍生于JS语言的一种轻量级的数据交换格式，也明白了JSON相对于一般的JS数据结构（尤其是对象）的差别，更进一步，仔细地讨论了JS中关于JSON处理的3个函数和细节。\n\n不过遗憾的是，以上所用的3个函数，不兼容IE7以及IE7之前的浏览器。有关兼容性的讨论，留待之后吧。如果想直接在应用上解决兼容性，那么可以套用JSON官方的js，可以解决。","cover":"/images/cover_json.jpg","link":"深入理解json.html","preview":"\u003cp\u003e深入理解JSON.\u003c/p\u003e\n","title":"深入理解JSON"},{"content":"\r\n\r\n# 如果不用promise\r\n\r\n\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eDocument\u003c/title\u003e\r\n  \u003cstyle\u003e\r\n    .ball{\r\n      width: 40px;\r\n      height: 40px;\r\n      border-radius: 20px;\r\n    }\r\n    .ball1{\r\n      background: red;\r\n    }\r\n    .ball2{\r\n      background: yellow;\r\n    }\r\n    .ball3{\r\n      background: green;\r\n    }\r\n  \u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"ball ball1\"\u003e\u003c/div\u003e\r\n  \u003cdiv class=\"ball ball2\"\u003e\u003c/div\u003e\r\n  \u003cdiv class=\"ball ball3\"\u003e\u003c/div\u003e\r\n  \u003cscript\u003e\r\n    var ball1 = document.querySelector('.ball1');\r\n    var ball2 = document.querySelector('.ball2');\r\n    var ball3 = document.querySelector('.ball3');\r\n    function animate(ball,distance,callback){\r\n      setTimeout(function(){\r\n        var marginLeft = parseInt(getComputedStyle(ball).marginLeft);\r\n        // console.log(marginLeft,distance);\r\n        if(marginLeft === distance){\r\n          callback();\r\n        }else{\r\n          if(marginLeft \u003c distance){\r\n            marginLeft ++;\r\n          }else{\r\n            marginLeft--;\r\n          }\r\n          ball.style.marginLeft = marginLeft + \"px\";\r\n          animate(ball,distance,callback);\r\n        }\r\n\r\n      },13);\r\n    }\r\n    animate(ball1,100,function(){\r\n      animate(ball2,200,function(){\r\n        animate(ball3,300,function(){\r\n          animate(ball3,150,function(){\r\n            animate(ball2,150,function(){\r\n              animate(ball1,150,function(){\r\n\r\n              })\r\n            })\r\n          })\r\n        })\r\n      })\r\n    });\r\n  \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n\r\n```\r\n\r\n## 用了promise\r\n```javascript\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eDocument\u003c/title\u003e\r\n  \u003cstyle\u003e\r\n    .ball{\r\n      width: 40px;\r\n      height: 40px;\r\n      border-radius: 20px;\r\n    }\r\n    .ball1{\r\n      background: red;\r\n    }\r\n    .ball2{\r\n      background: yellow;\r\n    }\r\n    .ball3{\r\n      background: green;\r\n    }\r\n  \u003c/style\u003e\r\n  \u003cscript src=\"./node_modules/bluebird/js/browser/bluebird.js\"\u003e\u003c/script\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"ball ball1\"\u003e\u003c/div\u003e\r\n  \u003cdiv class=\"ball ball2\"\u003e\u003c/div\u003e\r\n  \u003cdiv class=\"ball ball3\"\u003e\u003c/div\u003e\r\n  \u003cscript\u003e\r\n    var ball1 = document.querySelector('.ball1');\r\n    var ball2 = document.querySelector('.ball2');\r\n    var ball3 = document.querySelector('.ball3');\r\n    function promiseAnimate(ball,distance){\r\n    //构造函数声明模式，它在用来包裹非 promise API \r\n      return new Promise(function(resolve,reject){\r\n        function animate(){\r\n          setTimeout(function(){\r\n            var marginLeft = parseInt(getComputedStyle(ball).marginLeft);\r\n            if(marginLeft === distance){\r\n              resolve();\r\n            }else{\r\n              if(marginLeft \u003c distance){\r\n                marginLeft ++;\r\n              }else{\r\n                marginLeft--;\r\n              }\r\n              ball.style.marginLeft = marginLeft + \"px\";\r\n              animate();\r\n            }\r\n\r\n          },13);\r\n        }\r\n        animate()\r\n      });\r\n    }\r\n\r\n    promiseAnimate(ball1,100)\r\n      .then(function(){\r\n        console.log(111);\r\n        return promiseAnimate(ball2,200);\r\n      })\r\n      .then(function(){\r\n        return promiseAnimate(ball3,300);\r\n      })\r\n      .then(function(){\r\n        return promiseAnimate(ball3,150);\r\n      })\r\n      .then(function(){\r\n        return promiseAnimate(ball2,150);\r\n      })\r\n      .then(function(){\r\n        return promiseAnimate(ball1,150);\r\n      })\r\n  \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n\r\n```\r\n\r\n# jQuery中的promise\r\n\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cscript src=\"node_modules/jquery/dist/jquery.js\"\u003e\u003c/script\u003e\r\n  \u003cscript\u003e\r\n    var loadData = function(){\r\n      return $.ajax({\r\n        url:\"./a.json\",\r\n        type:\"get\"\r\n      })\r\n    }\r\n    loadData().then(function(data){\r\n      console.log(data);\r\n    });\r\n  \u003c/script\u003e\r\n\u003c/body\u003e\r\n```\r\n##  生成器\r\n```javascript\r\nfunction* inc () {\r\n let number = 0\r\n while (true)\r\n yield number++\r\n}\r\n\r\nlet test = inc()\r\n\r\nconsole.log(test.next().value) // -\u003e 0\r\nconsole.log(test.next().value) // -\u003e 1\r\nconsole.log(test.next().value) // -\u003e 2\r\nconsole.log(test.next().value) // -\u003e 2\r\nconsole.log(test.next().value) // -\u003e 2\r\nconsole.log(test.next().value) // -\u003e 2\r\nconsole.log(test.next().value) // -\u003e 2\r\nconsole.log(test.next().value) // -\u003e 2\r\n\r\n```","cover":"/images/bower-logo.svg","link":"理解promise.html","preview":"\u003cp\u003e理解promise\u003c/p\u003e\n","title":"理解promise"},{"content":"\n\n- [什么是闭包](#什么是闭包)\n- [闭包有什么作用？](#闭包有什么作用？)\n- [闭包内的微观世界](#闭包内的微观世界)\n- [闭包的应用场景](#闭包的应用场景)\n- [Javascript的垃圾回收机制](#Javascript的垃圾回收机制)\n\n### 什么是闭包？\n* 官方的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。\n* 相信很少有人能直接看懂这句话，因为他描述的太学术。其实这句话通俗的来说就是：JavaScript中所有的function都是一个闭包。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。看下面这段代码：\n\n```\nfunction a() { \n var i = 0; \n function b() { alert(++i); } \n return b;\n}\nvar c = a();\nc();\n```\n\n这段代码有两个特点：\n\n1. 函数b嵌套在函数a内部；\n2. 函数a返回函数b。\n\n引用关系如图：\n\n![](./images/20100703001016918.jpg)\n\n这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。\n\n这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说：\n\n当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。\n\n所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量。\n\n这使得只要目标对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。\n\n尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。\n\n即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新 的值，和上次那次调用的是各自独立的。\n\n### 闭包有什么作用？\n\n简而言之，闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量。\n\n这是对闭包作用的非常直白的描述，不专业也不严谨，但大概意思就是这样，理解闭包需要循序渐进的过程。\n\n在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。\n\n那么我们来想象另一种情况，如果a返回的不是函数b，情况就完全不同了。因为a执行完后，b没有被返回给a的外界，只是被a所引用，而此时a也只会被b引 用，因此函数a和b互相引用但又不被外界打扰(被外界引用)，函数a和b就会被GC回收。\n\n### 闭包内的微观世界\n如果要更加深入的了解闭包以及函数a和嵌套函数b的关系，我们需要引入另外几个概念：\n\n- 函数的执行环境(excution context)\n- 活动对象(call object)\n- 作用域(scope)\n- 作用域链(scope chain)。\n \n以函数a从定义到执行的过程为例阐述这几个概念。\n\n1. 当定义函数a的时候，js解释器会将函数a的作用域链(scope chain)设置为定义a时a所在的“环境”，如果a是一个全局函数，则scope chain中只有window对象。\n\n2. 当执行函数a的时候，a会进入相应的执行环境(excution context)。\n\n3. 在创建执行环境的过程中\n\n   - 首先会为a添加一个scope属性，即a的作用域，其值就为第1步中的scope chain。即a.scope=a的作用域链。\n\n   - 然后执行环境会创建一个活动对象(call object)。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。\n   \n   - 创建完活动对象后，把活动对象添加到a的作用域链的最顶端。此时a的作用域链包含了两个对象：a的活动对象和window对象。\n   \n   - 下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。\n    \n   - 最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。\n\n到此，整个函数a从定义到执行的步骤就完成了。\n\n此时a返回函数b的引用给c，又函数b的作用域链包含了对函数a的活动对象的引用，也就是说b可以访问到a中定义的所有变量和函数。\n\n函数b被c引用，函数b又依赖函数a，因此函数a在返回后不会被GC回收。\n\n当函数b执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：\n\n  - b的活动对象\n\n  - a的活动对象\n  \n  - window对象\n\n如下图所示：\n\n![](./images/20100703001017585.jpg)\n\n如图所示，当在函数b中访问一个变量的时候，搜索顺序是：\n\n1. 先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数a的活动对象，依次查找，直到找到为止。\n\n2. 如果函数b存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。\n\n3. 如果整个作用域链上都无法找到，则返回undefined。\n\n小结，本段中提到了两个重要的词语：函数的定义与执行。文中提到函数的作用域是在定义函数时候就已经确定，而不是在执行的时候确定（参看步骤1和3）。用一段代码来说明这个问题：\n```\nfunction f(x) { \n  var g = function () { return x; }\n  return g;\n}\nvar h = f(1);\nalert(h()); \n```\n这段代码中变量h指向了f中的那个匿名函数(由g返回)。\n\n假设函数h的作用域是在执行alert(h())确定的，那么此时h的作用域链是：h的活动对象-\u003ealert的活动对象-\u003ewindow对象。\n\n假设函数h的作用域是在定义时确定的，就是说h指向的那个匿名函数在定义的时候就已经确定了作用域。那么在执行的时候，h的作用域链为：h的活动对象-\u003ef的活动对象-\u003ewindow对象。\n\n如果第一种假设成立，那输出值就是undefined；如果第二种假设成立，输出值则为1。\n\n运行结果证明了第2个假设是正确的，说明函数的作用域确实是在定义这个函数的时候就已经确定了。\n\n### 闭包的应用场景\n保护函数内的变量安全。\n\n以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。\n在内存中维持一个变量。\n\n依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。\n\n通过保护变量的安全实现JS私有属性和私有方法（不能被外部访问）\n\n私有属性和方法在Constructor外是无法被访问的\n\n```\nfunction Constructor(...) {  \n  var that = this;  \n  var membername = value; \n  function membername(...) {...}\n}\n```\n以上3点是闭包最基本的应用场景，很多经典案例都源于此。\n\n### Javascript的垃圾回收机制\n在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。\n\n如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。\n\n因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。","cover":"/images/wallhaven-443187.jpg","link":"闭包.html","preview":"\u003cp\u003e闭包的原理。\u003c/p\u003e\n","title":"闭包的原理"},{"content":"\n\n- [JAVASCRIPT]\n    -\tHTML对象获取问题\t\n    -\tconst问题\t\n    -\tevent.x与event.y问题\t\n    -\twindow.location.href问题\t\n    -\tframe问题\t\n    -\t模态和非模态窗口问题\t\n    -\tfirefox与IE的父元素(parentElement)的区别\t\n    -\tdocument.formName.item(”itemName”) 问题\t\n    -\t集合类对象问题\t\n    -\t自定义属性问题\t\n    -\tinput.type属性问题\t\n    -\tevent.srcElement问题\t\n    -\tbody载入问题\t\n    -\t事件委托方法\t\n    -\tTable操作问题\t\n    -\t对象宽高赋值问题\t\n\n- [CSS]\t\n    -\tcursor:hand   VS   cursor:pointer\t\n    -\tinnerText在IE中能正常工作，但在FireFox中却不行.\t\n    -\tCSS透明\t\n    -\tcss中的width和padding\t\n    -\tFF和IE BOX模型解释不一致导致相差2px\t\n    -\tIE5 和IE6的BOX解释不一致\t\n    -\tul和ol列表缩进问题\t\n    -\t元素水平居中问题\t\n    -\tDiv的垂直居中问题\t\n    -\tmargin加倍的问题\t\n    -\tIE与宽度和高度的问题\t\n    -\t页面的最小宽度\t\n    -\tDIV浮动IE文本产生3象素的bug\t\n    -\tIE捉迷藏的问题\t\n    -\tfloat的div闭合;清除浮动;自适应高度\t\n    -\t高度不适应\t\n    -\tIE6下图片下有空隙产生\t\n    -   对齐文本与文本输入框\t\n    -\tLI中内容超过长度后以省略号显示\t\n    -\t为什么web标准中IE无法设置滚动条颜色了\t\n    -\t为什么无法定义1px左右高度的容器\t\n    -\t链接(a标签)的边框与背景\t\n    -\t超链接访问过后hover样式就不出现的问题\t\n    -\tFORM标签\t\n    -\t属性选择器(这个不能算是兼容,是隐藏css的一个bug)\t\n    -\t为什么FF下文本无法撑开容器的高度\t\n\n\n\n### JAVASCRIPT\n1.\tHTML对象获取问题\n\n    FireFox：document.getElementById(\"idName\");\n    ie:document.idname或者document.getElementById(\"idName\").\n    解决办法：统一使用document.getElementById(\"idName\");\n\n2.\tconst问题\n\n    说明:Firefox下,可以使用const关键字或var关键字来定义常量;\n    IE下,只能使用var关键字来定义常量. \n    解决方法：统一使用var关键字来定义常量.\n\n3.\tevent.x与event.y问题\n\n    说明:IE下,event对象有x,y属性,但是没有pageX,pageY属性;\n    Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. \n    解决方法：使用mX(mX   =   event.x   ?   event.x   :   event.pageX;)来代替IE下的event.x或者Firefox下的event.pageX. \n\n4.\twindow.location.href问题\n\n    说明:IE或者Firefox2.0.x下,可以使用window.location或window.location.href;\n    Firefox1.5.x下,只能使用window.location. \n    解决方法：使用window.location来代替window.location.href.\n\n5.\tframe问题\n\n    以下面的frame为例：\n    ```\n    \u003cframe   src=\"xxx.html\"   id=\"frameId\"   name=\"frameName\"   /\u003e\n    ```\n    (1)访问frame对象:\n    IE:使用window.frameId或者window.frameName来访问这个frame对象.   frameId和frameName可以同名。\n    Firefox:只能使用window.frameName来访问这个frame对象.\n    另外，在IE和Firefox中都可以使用window.document.getElementById(\"frameId\")来访问这个frame对象.\n    \n    (2)切换frame内容:\n    在 IE和Firefox中都可以使用window.document.getElementById(\"testFrame\").src   =   \"xxx.html\"或window.frameName.location   =   \"xxx.html\"来切换frame的内容.\n    如果需要将frame中的参数传回父窗口(注意不是opener,而是parent   frame)，可以在frame中使用parent来访问父窗口。例如：parent.document.form1.filename.value=\"Aqing\";\n\n6.\t模态和非模态窗口问题\n\n    说明:IE下,可以通过showModalDialog和showModelessDialog打开模态和非模态窗口;Firefox下则不能. \n    解决方法：直接使用window.open(pageURL,name,parameters)方式打开新窗口。\n    如果需要将子窗口中的参数传递回父窗口,可以在子窗口中使用window.opener来访问父窗口. \n    例如：var   parWin   =   window.opener;   parWin.document.getElementById(\"Aqing\").value   =   \"Aqing\"; \n\n7.\tfirefox与IE的父元素(parentElement)的区别\n\n    IE：obj.parentElement\n    firefox：obj.parentNode\n    解决方法:   因为firefox与IE都支持DOM,因此使用obj.parentNode是不错选择.\n\n8.\tdocument.formName.item(”itemName”) 问题\n\n    问题说明：IE下，可以使用document.formName.item(”itemName”) 或document.formName.elements [\"elementName\"]；Firefox 下，只能使用document.formName.elements[\"elementName\"]。\n    解决方法：统一使用document.formName.elements[\"elementName\"]。\n\n9.\t集合类对象问题\n\n    问题说明：IE下，可以使用 () 或 [] 获取集合类对象；Firefox下，只能使用 [ ]获取集合类对象。\n    解决方法：统一使用 [] 获取集合类对象。\n\n10.\t自定义属性问题\n\n    问题说明：IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute() 获取自定义属性；Firefox下，只能使用getAttribute() 获取自定义属性。\n    解决方法：统一通过getAttribute() 获取自定义属性。\n\n11.\tinput.type属性问题\n\n    问题说明：IE下input.type属性为只读；但是Firefox下input.type属性为读写。\n    解决办法：不修改input.type属性。如果必须要修改，可以先隐藏原来的input，然后在同样的位置再插入一个新的input元素。\n\n12.\tevent.srcElement问题\n\n    问题说明：IE下，even对象有srcElement属性，但是没有target属性；Firefox下，even对象有target属性，但是没有srcElement属性。\n    解决方法：使用srcObj = event.srcElement ?event.srcElement : event.target;\n    如果考虑第8条问题，就改用myEvent代替event即可。\n\n13.\tbody载入问题\n\n    问题说明：Firefox的body对象在body标签没有被浏览器完全读入之前就存在；而IE的body对象则必须在body标签被浏览器完全读入之后才存在。\n    [注] 这个问题尚未实际验证，待验证后再来修改。\n    [注] 经验证，IE6、Opera9以及FireFox2中不存在上述问题，单纯的JS脚本可以访问在脚本之前已经载入的所有对象和元素，即使这个元素还没有载入完成。\n\n14.\t事件委托方法\n\n    问题说明：IE下，使用document.body.onload = inject; 其中function inject()在这之前已被实现；在Firefox下，使用document.body.onload = inject();\n    解决方法：统一使用document.body.onload=new Function(’inject()’); 或者document.body.onload = function(){/* 这里是代码 */}\n    [注意] Function和function的区别。\n\n15.\tTable操作问题\n\n    问题说明：ie、firefox以及其它浏览器对于 table 标签的操作都各不相同，在ie中不允许对table和tr的innerHTML赋值，使用js增加一个tr时，使用appendChild方法也不管用。\n    解决方法：//向table追加一个空行：\n    var row = otable.insertRow(-1);var cell = document.createElement(\"td\");cell.innerHTML = \"\";cell.className = \"XXXX\";row.appendChild(cell);[注] 由于俺很少使用JS直接操作表格，这个问题没有遇见过。建议使用JS框架集来操作table，如JQuery。\n\n16.\t对象宽高赋值问题\n\n    问题说明：FireFox中类似obj.style.height = imgObj.height的语句无效。\n\n\n\n\n###\tCSS\n\n1.\tcursor:hand   VS   cursor:pointer\n\n    firefox不支持hand，但ie支持pointer\n    解决方法:   统一使用pointer\n\n2.\tinnerText在IE中能正常工作，但在FireFox中却不行.   \n\n    需用textContent。\n    解决方法:\n    ```\n    if(navigator.appName.indexOf(\"Explorer\")   \u003e   -1){\n            document.getElementById('element').innerText   =   \"my   text\";\n    }   else{\n            document.getElementById('element').textContent   =   \"my   text\";\n    }\n    ```\n3.\tCSS透明\n\n    IE：filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60)。\n    FF：opacity:0.6。\n\n4.\tcss中的width和padding\n\n    在IE7和FF中width宽度不包括padding，在Ie6中包括padding.\n\n5.\tFF和IEBOX模型解释不一致导致相差2px\n\n    box.style{width:100;border 1px;} \n    ie理解为box.width = 100 \n    ff理解为box.width = 100 + 1*2 = 102  //加上边框2px \n    解决方法：div{margin:30px!important;margin:28px;}\n    注意这两个margin的顺序一定不能写反， IE不能识别!important这个属性，但别的浏览器可以识别。所以在IE下其实解释成这样：div{maring:30px;margin:28px}\n    重复定义的话按照最后一个来执行，所以不可以只写margin:XXpx!important;\n\n6.\tIE5 和IE6的BOX解释不一致\n\n    IE5下div{width:300px;margin:0 10px 0 10px;}\n    div 的宽度会被解释为300px-10px(右填充)-10px(左填充)，最终div的宽度为280px，而在IE6和其他浏览器上宽度则是以 300px+10px(右填充)+10px(左填充)=320px来计算的。这时我们可以做如下修改 div{width:300px!important;width /**/:340px;margin:0 10px 0 10px}\n\n7.\tul和ol列表缩进问题\n\n    消除ul、ol等列表的缩进时，样式应写成：list-style:none;margin:0px;padding:0px;\n    经验证，在IE中，设置margin:0px可以去除列表的上下左右缩进、空白以及列表编号或圆点，设置padding对样式没有影响；在 Firefox 中，设置margin:0px仅仅可以去除上下的空白，设置padding:0px后仅仅可以去掉左右缩进，还必须设置list- style:none才能去除列表编号或圆点。也就是说，在IE中仅仅设置margin:0px即可达到最终效果，而在Firefox中必须同时设置margin:0px、 padding:0px以及list-style:none三项才能达到最终效果。\n\n8.\t元素水平居中问题\n\n    FF: margin:0 auto;\n    IE: 父级{ text-align:center; }\n\n9.\tDiv的垂直居中问题\n\n    vertical-align:middle; 将行距增加到和整个DIV一样高：line-height:200px; 然后插入文字，就垂直居中了。缺点是要控制内容不要换行。\n\n10.\tmargin加倍的问题\n\n    设置为float的div在ie下设置的margin会加倍。这是一个ie6都存在的bug。解决方案是在这个div里面加上display:inline; \n    例如：\n    ```\n    \u003cdiv id=”imfloat”\u003e\n    相应的css为\n    #imfloat{ \n    float:left; \n    margin:5px;/*IE下理解为10px*/ \n    display:inline;/*IE下再理解为5px*/}\n    ```\n\n11.\tIE与宽度和高度的问题\n\n    IE不认得min-这个定义，但实际上它把正常的width和height当作有min的情况来使。这样问题就大了，如果只用宽度和高度，正常的浏览器里这两个值就不会变，如果只用min-width和min-height的话，IE下面根本等于没有设置宽度和高度。\n    比如要设置背景图片，这个宽度是比较重要的。要解决这个问题，可以这样：\n    \n    ```\n    #box{ \n        width: 80px; \n        height: 35px;}\n    html\u003ebody #box{ \n        width: auto; \n        height: auto; \n        min-width: 80px; \n        min-height: 35px;}\n    ```\n\n12.\t页面的最小宽度\n\n    如上一个问题，IE不识别min，要实现最小宽度，可用下面的方法：\n    ```\n    #container{ \n        min-width: 600px; \n        width:expression(document.body.clientWidth\u003c 600? \"600px\": \"auto\" );} \n    ```\n    第一个min-width是正常的；但第2行的width使用了Javascript，这只有IE才认得，这也会让你的HTML文档不太正规。它实际上通过Javascript的判断来实现最小宽度。\n\n13.\tDIV浮动IE文本产生3象素的bug\n\n    左边对象浮动，右边采用外补丁的左边距来定位，右边对象内的文本会离左边有3px的间距. \n    ```\n    #box{ \n        float:left; \n        width:800px;} \n    #left{ \n        float:left; \n        width:50%;} \n    #right{ \n        width:50%;\n        } \n    *html #left{ \n        margin-right:-3px; //这句是关键\n        } \n    \u003cdiv id=\"box\"\u003e\n    \u003cdiv id=\"left\"\u003e\u003c/div\u003e\n    \u003cdiv id=\"right\"\u003e\u003c/div\u003e\n    \u003c/div\u003e\n    ```\n14.\tIE捉迷藏的问题\n\n    当div应用复杂的时候每个栏中又有一些链接，DIV等这个时候容易发生捉迷藏的问题。\n    有些内容显示不出来，当鼠标选择这个区域是发现内容确实在页面。\n    解决办法：对#layout使用line-height属性或者给#layout使用固定高和宽。页面结构尽量简单。\n\n15.\tfloat的div闭合;清除浮动;自适应高度\n\n    ①例如：\n    ```\n    \u003cdiv id=”floatA”\u003e\u003cdiv id=”floatB”\u003e\u003cdiv id=”NOTfloatC”\u003e\n    ```\n    这里的NOTfloatC并不希望继续平移，而是希望往下排。(其中floatA、floatB的属性已经设置为float:left;) \n    这段代码在IE中毫无问题，问题出在FF。原因是NOTfloatC并非float标签，必须将float标签闭合。\n    ```\n    在\u003cdiv class=”floatB”\u003e\u003cdiv class=”NOTfloatC”\u003e之间加上\u003cdiv class=”clear”\u003e\n    这个div一定要注意位置，而且必须与两个具有float属性的div同级，之间不能存在嵌套关系，否则会产生异常。\n    并且将clear这种样式定义为为如下即可：.clear{clear:both;}\n    ```\n    ②作为外部 wrapper 的 div 不要定死高度,为了让高度能自适应，要在wrapper里面加上overflow:hidden; 当包含float的box的时候，高度自适应在IE下无效，这时候应该触发IE的layout私有属性(万恶的IE啊！)用zoom:1;可以做到，这样就达到了兼容。\n    例如某一个wrapper如下定义：\n    ```\n    .colwrapper{overflow:hidden; zoom:1; margin:5px auto;}\n    ```\n    ③对于排版,我们用得最多的css描述可能就是float:left.有的时候我们需要在n栏的float div后面做一个统一的背景,譬如:\n    ``` \n    \u003cdiv id=”page”\u003e\n    \u003cdiv id=”left”\u003e\u003c/div\u003e\n    \u003cdiv id=”center”\u003e\u003c/div\u003e\n    \u003cdiv id=”right”\u003e\u003c/div\u003e\n    \u003c/div\u003e\n    ```\n    比如我们要将page的背景设置成蓝色,以达到所有三栏的背景颜色是蓝色的目的,但是我们会发现随着left center right的向下拉长,而page居然保存高度不变,问题来了,原因在于page不是float属性,而我们的page由于要居中,不能设置成float,所以我们应该这样解决：\n    ```\n    \u003cdiv id=”page”\u003e\n    \u003cdiv id=”bg” style=”float:left;width:100%”\u003e\n    \u003cdiv id=”left”\u003e\u003c/div\u003e\n    \u003cdiv id=”center”\u003e\u003c/div\u003e\n    \u003cdiv id=”right”\u003e\u003c/div\u003e\n    \u003c/div\u003e\n    ```\n    再嵌入一个float left而宽度是100%的DIV解决之。\n    ④万能float 闭合(非常重要!) \n    关于 clear float 的原理可参见 [How To Clear Floats Without Structural Markup],将以下代码加入Global CSS 中,给需要闭合的div加上class=\"clearfix\" 即可,屡试不爽。\n    ```\n    /* Clear Fix */ \n    .clearfix:after { \n        content:\".\"; display:block;\n         height:0; \n         clear:both; \n         visibility:hidden; } \n    .clearfix { \n        display:inline-block; \n        } \n    /* Hide from IE Mac */ \n    .clearfix {\n        display:block;\n        } \n    /* End hide from IE Mac */ \n    /* end of clearfix */ \n    或者这样设置：.hackbox{ display:table; //将对象作为块元素级的表格显示}\n    ```\n\n16.\t高度不适应\n    高度不适应是当内层对象的高度发生变化时外层高度不能自动进行调节，特别是当内层对象使用margin 或padding时。\n    例：\n    ```\n    #box {background-color:#eee; } \n    #box p {\n        margin-top: 20px;\n        margin-bottom: 20px; \n        text-align:center; \n        } \n    \u003cdiv id=\"box\"\u003e\n    \u003cp\u003ep对象中的内容\u003c/p\u003e\n    \u003c/div\u003e\n    解决技巧：在P对象上下各加2个空的div对象CSS代码{height:0px;overflow:hidden;}\n    或者为DIV加上border属性。\n    ```\n17.\tIE6下图片下有空隙产生\n\n    解决这个BUG的技巧有很多,可以是改变html的排版,或者设置img为display:block或者设置vertical-align属性为vertical-align:top/bottom/middle/text-bottom 都可以解决.\n\n18.\t对齐文本与文本输入框\n    ```\n    加上vertical-align:middle; \n    \u003cstyle type=\"text/css\"\u003e\n    \u003c!--\n    input { \n    width:200px; \n    height:30px; \n    border:1px solid red; \n    vertical-align:middle; \n    } \n    --\u003e\n    \u003c/style\u003e\n    经验证，在IE下任一版本都不适用，而ff、opera、safari、chrome均OK！\n    ```\n19.\tLI中内容超过长度后以省略号显示\n\n    此技巧适用与IE、Opera、safari、chrom浏览器，FF暂不支持。\n    ```\n    \u003cstyle type=\"text/css\"\u003e\n    \u003c!--\n    li { \n    width:200px; \n    white-space:nowrap; \n    text-overflow:ellipsis; \n    -o-text-overflow:ellipsis; \n    overflow: hidden; \n    }\n    --\u003e\n    \u003c/style\u003e\n    ```\n20.\t为什么web标准中IE无法设置滚动条颜色了\n\n    解决办法是将body换成html \n    ```\n    \u003c!DOCTYPE html PUBLIC \"//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u003e\n    \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=gb2312\" /\u003e\n    \u003cstyle type=\"text/css\"\u003e\n    \u003c!-- \n    html { \n    scrollbar-face-color:#f6f6f6; \n    scrollbar-highlight-color:#fff; \n    scrollbar-shadow-color:#eeeeee; \n    scrollbar-3dlight-color:#eeeeee; \n    scrollbar-arrow-color:#000; \n    scrollbar-track-color:#fff; \n    scrollbar-darkshadow-color:#fff; \n    } \n    --\u003e\n    \u003c/style\u003e\n    ```\n21.\t为什么无法定义1px左右高度的容器\n\n    IE6下这个问题是因为默认的行高造成的,解决的技巧也有很多：\n    例如:overflow:hidden　 zoom:0.08 　 line-height:1px\n\n22.\t链接(a标签)的边框与背景\n\n    a链接加边框和背景色，需设置 display: block, 同时设置 float: left 保证不换行。参照menubar, 给 a 和menubar设置高度是为了避免底边显示错位, 若不设 height, 可以在menubar中插入一个空格。\n\n23.\t超链接访问过后hover样式就不出现的问题\n\n    被点击访问过的超链接样式不在具有hover和active了,很多人应该都遇到过这个问题,解决技巧是改变CSS属性的排列顺序: L-V-H-A \n    ```\n    \u003cstyle type=\"text/css\"\u003e\n    \u003c!--\n    a:link {} \n    a:visited {} \n    a:hover {} \n    a:active {} \n    --\u003e\n    \u003c/style\u003e\n    ```\n24.\tFORM标签\n\n    这个标签在IE中,将会自动margin一些边距,而在FF中margin则是0,因此,如果想显示一致,所以最好在css中指定margin和 padding,针对上面两个问题,我的css中一般首先都使用这样的样式ul,form{margin:0;padding:0;}。\n\n25.\t属性选择器(这个不能算是兼容,是隐藏css的一个bug)\n    ```\n    p[id]{}div[id]{} \n    ```\n    这个对于IE6.0和IE6.0以下的版本都隐藏,FF和OPera作用.属性选择器和子选择器还是有区别的,子选择器的范围从形式来说缩小了,属性选择器的范围比较大,如p[id]中,所有p标签中有id的都是同样式的.\n\n26.\t为什么FF下文本无法撑开容器的高度\n\n    标准浏览器中固定高度值的容器是不会象IE6里那样被撑开的,那我又想固定高度,又想能被撑开需要怎样设置呢？办法就是去掉height设置min-height:200px;这里为了照顾不认识min-height的IE6 可以这样定义:\n\n    ```\n    { \n    height:auto!important; \n    height:200px; \n    min-height:200px; \n    } \n    ```\n27. 怎么样才能让层显示在FLASH之上呢\n\n    解决的办法是给FLASH设置透明\n\n    ```\n    \u003cparam name=\"wmode\" value=\"transparent\" /\u003e\n    ```\n","cover":"/images/wallhaven-443187.jpg","link":"兼容性问题汇总.html","preview":"\u003cp\u003e兼容性问题汇总.\u003c/p\u003e\n","title":"兼容性问题汇总"},{"content":"\n\n- [点透出现的场景](#点透出现的场景)\n- [出现点透原因](#出现点透原因)\n- [解决方案](#解决方案)\n- [现有解决方案框架（库）](#现有解决方案框架（库）)\n\n### 点透出现的场景\n\n1. A/B两个层上下z轴重叠。\n\n2. 上层的A点击后消失或移开。（这一点很重要）\n\n3. B元素本身有默认click事件（如a标签） 或 B绑定了click事件。\n\n在以上情况下，点击A/B重叠的部分，就会出现点透的现象。\n    \n### 出现点透原因\n\nclick延迟，延迟，还是延迟。\n\n在移动端不使用click而用touch事件代替触摸是因为click事件有着明显的延迟，具体touchstart与click的区别如下：\n\n1. touchstart：在这个DOM（或冒泡到这个DOM）上手指触摸开始即能立即触发\n\n2. click：在这个DOM（或冒泡到这个DOM）上手指触摸开始，且手指未曾在屏幕上移动（某些浏览器允许移动一个非常小的位移值），且在这个dom上手指离开屏幕，且触摸和离开屏幕之间的间隔时间较短（某些浏览器不检测间隔时间，也会触发click）才能触发\n\n也就是说，事件的触发时间按由早到晚排列为：touchstart 早于 touchend 早于 click。亦即click的触发是有延迟的，这个时间大概在300ms左右。\n\n由于我们在touchstart阶段就已经隐藏了罩层A，当click被触发时候，能够被点击的元素则是其下的B元素，根据click事件的触发规则：\n\n只有在被触发时，当前有click事件的元素显示，且在面朝用户的最前端时，才触发click事件。\n由于B绑定了click事件（或者B本身默认存在click事件），所以B的click事件被触发，产生了点透的情况。\n\n### 解决方案\n\n1. 对于B元素本身没有默认click事件的情况（无a标签等），应统一使用touch事件，统一代码风格，并且由于click事件在移动端的延迟要大很多，不利于用户体验，所以关于触摸事件应尽量使用touch相关事件。\n\n2. 对于B元素本身存在默认click事件的情况,应及时取消B元素的默认点击事件，从而阻止click事件的产生。即应添加 代码如下：\n\n    ```\n        if(eve == \"touchsend\") e.preventDefault();\n    ``` \n\n3. 对于遮盖浮层，由于遮盖浮层的点击即使有小延迟也是没有关系的，反而会有疑似更好的用户体验，所以这种情况，可以针对遮盖浮层自己采用click事件，这样就不会出现点透问题。\n\n### 现有解决方案框架（库）\n\n1. 众所周知，zepto的tap事件是有点透问题的，但是最新版的zepto已经修复了这个问题。\n\n2. 在zepto修复问题之前，有fastclick、hammer等通用库可以使用。","cover":"/images/web.jpg","link":"移动端的click点透问题.html","preview":"\u003cp\u003e移动端的click点透问题及解决方案。\u003c/p\u003e\n","title":"移动端的click点透问题"},{"content":"\r\n- [代码执行可视化](http://pythontutor.com/visualize.html)\r\n- [js各种对比对照表](https://dorey.github.io/JavaScript-Equality-Table/)\r\n- [正则可视化](https://regexper.com/)\r\n- [css3动画代码](http://anicollection.github.io/#/)\r\n- [css选择器速查表](https://kimblim.dk/css-tests/selectors/)\r\n- [移动端开发经验汇总](https://github.com/doyoe/trip)\r\n- 项目管理\r\n    + [禅道](http://www.zentao.net/)\r\n    + [柠檬](http://www.lemonpm.com)\r\n    + [蒲公英](https://bug.pgyer.com/)\r\n- 常见免费api\r\n    + [百度api](http://apistore.baidu.com/)\r\n- [vue项目收藏](https://madewithvuejs.com/)\r\n- 图床\r\n    + [图床1](http://jiantuku.com/#/uploads?scope=all)\r\n    +  [图床2](http://mpic.lzhaofu.cn/) \r\n    + [图床3](http://www.tietuku.com/)\r\n- [markdown生成html](https://github.com/i5ting/tocmd.gem)\r\n","cover":"/images/tool.jpg","link":"常用前端资源汇总.html","preview":"\u003cp\u003e常用前端资源汇总\u003c/p\u003e\n","title":"常用前端资源汇总"},{"content":"\r\n\u003c!-- TOC --\u003e\r\n\r\n\r\n\u003c!-- /TOC --\u003e\r\n\r\n1. 百度搜索一下TeleportUltra软件，安装一下\r\n2. 打开这个软件\r\n![](http://i1.piimg.com/567571/d0be50516a7e2b70.png)\r\n3. 点击左上角那一道闪电\r\n![](http://i1.piimg.com/567571/1d03dc7a0aa55f36.png)\r\n4. 在弹出来的几个选项当中，选择`复制一个网站，包含该网站的目录结构`\r\n5. 把你要下载的网站的网址输入进去\r\n![](http://p1.bpimg.com/567571/79bec75601b46bdf.png)\r\n![](http://p1.bqimg.com/567571/77e15f9ca8e2c5fd.png)\r\n![](http://p1.bpimg.com/567571/9a177a27f9d92ccd.png)\r\n6. 点击三角启动，过一会儿，整个网站都会被下载下来\r\n![](http://p1.bqimg.com/567571/a6f4b028091b93f6.png)","cover":"","link":"扒网站教程.html","preview":"\u003cp\u003e扒网站\u003c/p\u003e\n","title":"扒网站教程"},{"content":"\r\n\u003c!-- TOC --\u003e\r\n\r\n- [github源码地址](#github源码地址)\r\n- [说明](#说明)\r\n- [package.json示例如下：](#packagejson示例如下)\r\n- [开发阶段代码如下](#开发阶段代码如下)\r\n    - [index.html代码示例](#indexhtml代码示例)\r\n    - [包装jquery.js](#包装jqueryjs)\r\n    - [主模块main.js](#主模块mainjs)\r\n    - [第三方模块a.js代码如下：](#第三方模块ajs代码如下)\r\n- [上线打包阶段](#上线打包阶段)\r\n\r\n\u003c!-- /TOC --\u003e\r\n## github源码地址\r\nhttps://github.com/black-pony/seajs-gulp-pack\r\n## 说明\r\n大家先把我的代码下载下来，对着这篇文档搞明白了再去玩自己的项目，否则会遇到问题的\r\n\r\n## package.json示例如下：\r\n```json\r\n{\r\n  \"name\": \"iheima\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\"\r\n  },\r\n  \"keywords\": [],\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"jquery\": \"^3.1.1\",\r\n    \"seajs\": \"^3.0.2\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"gulp\": \"^3.9.1\",\r\n    \"gulp-cmd-pack\": \"^1.0.9\",\r\n    \"gulp-uglify\": \"^2.0.0\"\r\n  }\r\n}\r\n\r\n```\r\n\r\n## 开发阶段代码如下\r\n### index.html代码示例\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n    \u003cscript src=\"./node_modules/seajs/dist/sea-debug.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        seajs.config({\r\n            base:'./js',\r\n            alias:{\r\n                jquery:'../node_modules/jquery/dist/jquery'\r\n            }\r\n        });\r\n        seajs.use('main');\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### 包装jquery.js\r\n这块直接拷贝我包装好的文件，不要自己尝试去修改，否则打包好了会报错的\r\n\r\n### 主模块main.js\r\n```javascript\r\ndefine(function(require,module,exports){\r\n    \"use strict\";\r\n    var a = require('./a');\r\n    $(document).click(function(){\r\n        alert('1');\r\n    });\r\n    console.log(2322);\r\n    console.log(a);\r\n});\r\n```\r\n\r\n### 第三方模块a.js代码如下：\r\n```javascript\r\ndefine(function(require,exports,module){\r\n    \"use strict\";\r\n    module.exports = {title:22};\r\n});\r\n```\r\n\r\n## 上线打包阶段\r\n1. 修改index.html代码如下：\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n    \u003cscript src=\"./node_modules/seajs/dist/sea-debug.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        // seajs.config({\r\n        //     base:'./js',\r\n        //     alias:{\r\n        //         jquery:'../node_modules/jquery/dist/jquery'\r\n        //     }\r\n        // });\r\n        // seajs.use('main');\r\n\r\n         seajs.config({\r\n            base:'./dist/'\r\n        });\r\n        seajs.use('main')\r\n\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n2. gulpfile.js如下：\r\n\r\n```javascript\r\n\"use strict\";\r\nvar gulp = require('gulp');\r\nvar cmdPack = require('gulp-cmd-pack');\r\nvar uglify = require('gulp-uglify');\r\n \r\ngulp.task('cmd', function () {\r\n    gulp.src('./js/main.js') //main文件 \r\n        .pipe(cmdPack({\r\n            mainId: 'main', //初始化模块的id \r\n            base: './js', //base路径 \r\n            alias: {\r\n                jquery: '../node_modules/jquery/dist/jquery'\r\n            }\r\n        }))\r\n        .pipe(uglify({ //压缩文件，这一步是可选的 \r\n            mangle: {\r\n                except: ['require']\r\n            }\r\n        }))\r\n        .pipe(gulp.dest('./dist'));//输出到目录 \r\n});\r\n ```","cover":"","link":"打包sea.js.html","preview":"\u003cp\u003e打包sea.js代码\u003c/p\u003e\n","title":"打包sea.js"},{"content":"\r\n\r\n指令名 | 含义 | 示例代码\r\n---------|----------|---------\r\n ng-app | 限定angular所管理的范围 | C1\r\n ng-init | 初始化数据模型 | C2\r\n ng-model | 数据模型 | C3\r\n ng-click | 点击 | \r\n ng-dblclick | 双击 |\r\n ng-change | select,checkbox标签独有的，不支持双向绑定 |\r\n ng-submit | 提交表单相关 |\r\n ng-cloak | 样式相关 |\r\n ng-class | 类 |\r\n ng-show | 显示隐藏 |\r\n ng-hide | 显示隐藏 |\r\n ng-bind | 绑定数据模型 |\r\n ng-switch | 判断 |\r\n ng-switch-when | 判断 |\r\n ng-if | 显示隐藏、判断 |\r\n","cover":"/images/bower-logo.svg","link":"angular_内置指令汇总.html","preview":"\u003cp\u003eangular内置指令汇总\u003c/p\u003e\n","title":"angular内置指令汇总"},{"content":"\r\n\r\n- addClass() 给元素添加指定的类。\r\n- after() 在元素的后面插入内容。\r\n- append() 将内容插入到元素的尾部。\r\n- attr() 获取或者设置元素的属性\r\n- bind()/on() 给选中元素的一个或者多个事件附加一个事件处理程序。\r\n- children() 获取元素的子元素。\r\n- clone() 创建一个元素的深复制。\r\n- contents() 获取每个元素的子节点，返回的集合中包含文本和注释节点。\r\n- css() 获取或设置元素的 style 属性值。\r\n- data() 存储或返回与元素关联的指定数据值。\r\n- eq() 获取指定索引位置的元素。\r\n- find() 过滤元素的子节点，只能通过标签名过滤。\r\n- hasClass() 确定元素本身是否分配了给定的类。\r\n- html() 获取或者设置元素的HTML内容。\r\n- next() 获取紧跟元素的兄弟元素。\r\n- off()/unbind() 通过名称移除一个事件处理程序。\r\n- parent() 获取元素的父元素。\r\n- prepend() 将内容插入到元素的开头。\r\n- prop() 获取或设置元素的属性\r\n- ready() 指定一个DOM加载完成时执行的函数。\r\n- remove() 从DOM中移除元素。\r\n- removeAttr() 从元素中移除一个属性（attribute）。\r\n- removeClass() 从元素中移除一个、多个或者所有类。\r\n- removeData() 从元素中移除先前存储的数据。\r\n- repalceWith() 使用提供的新内容替换元素。\r\n- text() 获取或者设置元素中合并的文本内容。\r\n- toggleClass() 从元素中添加或者移除一个或者多个类。\r\n- triggerHandler() 执行附加给元素的某个事件的所有事件处理程序。(triggerHandler() 方法与 trigger() 方法类似。不同的是它不会触发事件（比如表单提交）的默认行为，而且只影响第一个匹配元素。)\r\n- val() 获取或设置元素的当前值。\r\n- wrap() 使用指定的HTML结构包裹元素。","cover":"/images/bower-logo.svg","link":"angular_jquery.html","preview":"\u003cp\u003eangular中使用jquery\u003c/p\u003e\n","title":"angular中使用jquery"},{"content":"\n\n- [同源策略](#同源策略)\n    - [什么是跨域](#什么是跨域)\n    - [跨域解决方案](#跨域解决方案)\n- [JSONP原理](#JSONP原理)\n    - [JSONP的原理（1）](#JSONP的原理（1）)\n    - [JSONP的原理（2）](#JSONP的原理（2）)\n    - [JSONP的原理（3）](#JSONP的原理（3）)\n- [JSONP的使用](#JSONP的使用)\n    - [Ajax请求JSONP的封装](#Ajax请求JSONP的封装)\n\n### 同源策略\n\n1. 什么是跨域\n\n        同源策略是浏览器的一种安全策略，所谓同源指的是请求URL地址中的协议、域名和端口号都相同，\n        只要其中之一不相同就是跨域。\n        同源策略主要是为了保证浏览器的安全性\n        在同源策略下，浏览器不允许Ajax跨域获取服务器数据\n\n        说简单点：跨域是指从一个域名的网页去请求另一个域名的资源。\n        只要协议、域名、端口有任何一个的不同，就被当作是跨域。 \n\n2. 跨域解决方案\n\n        1、jsonp，\n        2、document.domain + iframe\n        3、location.hash + iframe\n        4、window.name + iframe\n        5、window.postMessage\n        6、flash 等第三方插件\n\n        99%的公司都在使用jsonp。\n\n        注：前端解决跨域问题的8种方案\n        http://www.cnblogs.com/JChen666/p/3399951.html\n\n\n### JSONP原理\n\n1. JSONP的原理（1）\n\n        静态script标签的src属性进行跨域请求\n            如果使用src这种方法进行跨域的话，一定要把这段获取数据的代码上面先行加载，\n            使用数据的方法放在后加载，这种方法的缺点就是非常的不灵活。\n        这种方法已经极少使用，了解即可\n\n        利用script标签的跨域能力，这就是jsonp的基础。\n        利用js构造一个script标签，把json的url赋给script的scr属性，\n        把这个script插入到dom里，让浏览器去获取。\n\n\n2. JSONP的原理（2）\n\n\t\t动态创建script标签，通过标签的src属性发送请求\n\t\t动态创建script标签发出去的请求是异步请求\n\t\t服务器响应的内容【函数调用】\n\n\n3. JSONP的原理（3）\n\n        1、jsonp的本质：动态创建script标签，然后通过它src属性发送跨域请求，\n        然后服务器响应的数据格式为【函数调用（foo实参）】\n        所以在发送请求之前必须显示先声明一个函数，并且函数的名字与参数中传递的名字要一致，\n        这里声明的函数是由服务器响应的内容，（实际就是一段js代码-函数调用）来调用\n\n        2、注意：ajax和jsonp其实本质上是不同的东西。\n        ajax的核心是通过XmlHttpRequest获取非本页内容，\n        而jsonp的核心则是动态添加\u003cscript\u003e标签来调用服务器提供的js脚本。\n\n        3、贺师俊 --- JSONP 的工作原理是什么\n        就是利用\u003cscript\u003e标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。\n        当需要通讯时，本站脚本创建一个\u003cscript\u003e元素，地址指向第三方的API网址，\n            形如： \u003cscript src=\"http://www.example.net/api?param1=1\u0026param2=2\"\u003e\u003c/script\u003e \n        并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 \n        第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如： \n            callback({\"name\":\"hax\",\"gender\":\"Male\"}) \n        这样浏览器会调用callback函数，并传递解析后json对象作为参数。\n        本站脚本可在callback函数里处理所传入的数据。 \n\n        4、定义函数，一定要写在调用JSONP之前。也就是，调用任何外部js，都没有函数声明头的提升。\n\n### JSONP的使用\n1. Ajax请求JSONP的封装\n\n        function ajax4Jsonp(obj) {\n            // jsonp仅仅支持get请求\n            var defaults = {\n                url: '#',\n                dataType: 'jsonp',\n                jsonp: 'callback',\n                data: {},\n                success: function(data) {\n                    console.log(data);\n                }\n            }\n\n            for (var key in obj) {\n                defaults[key] = obj[key];\n            }\n            // 这里是默认的回调函数名称\n            // expando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n            var cbName = 'jQuery' + ('1.11.1' + Math.random()).replace(/\\D/g, \"\") + '_' + (new Date().getTime());\n            if (defaults.jsonpCallback) {\n                cbName = defaults.jsonpCallback;\n            }\n\n            // 这里就是回调函数，调用方式：服务器响应内容来调用\n            // 向window对象中添加了一个方法，方法名称是变量cbName的值\n            window[cbName] = function(data) {\n                defaults.success(data); //这里success的data是实参\n            }\n\n            var param = '';\n            for (var attr in defaults.data) {\n                param += attr + '=' + defaults.data[attr] + '\u0026';\n            }\n            if (param) {\n                param = param.substring(0, param.length - 1);\n                param = '\u0026' + param;\n            }\n            var script = document.createElement('script');\n            script.src = defaults.url + '?' + defaults.jsonp + '=' + cbName + param;\n            var head = document.getElementsByTagName('head')[0];\n            head.appendChild(script);\n\n            // abc({\"username\":\"zhangsan\",\"password\":\"123\"})\n        }\n\n2. jQuery的Ajax请求JSONP的使用\n\n        $.ajax({\n            url: \"url\",\n            data: \"data\",\n            dataType: \"jsonp\",\n            success: function (response) {\n                \n            }\n        });","cover":"/images/jsonp.jpg","link":"跨域.html","preview":"\u003cp\u003e跨域问题的解决方案。\u003c/p\u003e\n","title":"跨域"},{"content":"\r\n\r\n- [什么是Ajax](#什么是Ajax)\r\n- [隐藏帧技术](#隐藏帧技术)\r\n- [Ajax请求步骤](#Ajax请求步骤)\r\n- [Ajax封装](#Ajax封装)\r\n- [jQuery的ajax方法](#jQuery的ajax方法)\r\n- [json数据解析](#json数据解析)\r\n\r\n\r\n### 什么是Ajax\r\n在不刷新页面的情况下，浏览器悄悄地、异步地向服务器发出HTTP请求。服务器收到请求后，传回新的格式化数据回来（通常是JSON）。浏览器解析JSON，通过DOM将新数据呈递显示，页面仅局部刷新。\r\n\r\n### 隐藏帧技术\r\n在没有Ajax之前，可以通过隐藏的iframe标签达到异步加载的效果。\r\n\r\n```\r\nhtml部份：\r\n\u003cdiv\u003e\r\n    \u003cform action=\"./iframe.php\" method=\"post\" target=\"myframe\"\u003e\r\n        用户名：\u003cinput type=\"text\" name=\"username\"\u003e\u003cspan id=\"info\"\u003e\u003c/span\u003e\u003cbr\u003e\r\n        密码：\u003cinput type=\"text\" name=\"password\"\u003e\r\n        \u003cinput type=\"submit\" value=\"登录\"\u003e\r\n    \u003c/form\u003e\r\n\u003c/div\u003e\r\n\u003ciframe width=\"0\" height=\"0\"  frameborder=\"0\" name=\"myframe\"\u003e\u003c/iframe\u003e\r\n\r\n后台php部份：\r\n\u003c?php \r\n$uname = $_POST['username'];\r\n$pw = $_POST['password'];\r\n\r\nif($uname == 'admin' \u0026\u0026 $pw == '123'){ ?\u003e\r\n    \u003cscript type=\"text/javascript\"\u003e\r\n        parent.document.getElementById('info').innerHTML = '登录成功';\r\n    \u003c/script\u003e\r\n\u003c?php }else{ ?\u003e\r\n    \u003cscript type=\"text/javascript\"\u003e\r\n        parent.document.getElementById('info').innerHTML = '登录失败';\r\n    \u003c/script\u003e\r\n\u003c?php } ?\u003e\r\n\r\n```\r\n\r\n页面刷新了，刷新的虽然只是iframe子页面，这种做法是实现了页面的局部更新，但是没有异步来实现。\r\n\r\n### Ajax请求步骤\r\n```\r\n1. 创建XMLHttpRequest对象\r\nvar xhr = null;\r\nwindow.XMLHttpRequest \r\n? xhr = new XMLHttpRequest(); //FF \r\n: xhr = new ActiveXObject(\"Microsoft.XMLHTTP\") //IE下\r\n\r\n2. 准备发送\r\n/*\r\n参数一：请求方式（get获取数据；post提交数据）\r\n参数二：请求地址\r\n参数三：同步或者异步标志位，默认是true表示异步，false表示同步\r\n\r\n如果是get请求那么请求参数必须在url中传递\r\nencodeURI()用来对中文参数进行编码，防止乱码\r\n\r\npost请求参数通过send传递，不需要通过encodeURI()转码\r\n必须设置请求头信息\r\n*/\r\n\r\n//Get方式\r\nvar param = 'username=' + uname + 'password=' + pw;\r\nxhr.open('get', '03get.php?' + encodeURI(param), true);\r\nxhr.setRequestHeader(\"If-Modified-Since\",\"0\")；//设置浏览器不使用缓存(可以不加)\r\n\r\n/*\r\n//Post方式\r\nxhr.open(\"post\",\"test.ashx\",true);\r\nxhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");\r\n*/\r\n\r\n3. 发送数据\r\n//Get方式发送数据\r\nxhr.send(null);//异步对象发送请求\r\n\r\n/*\r\n//以post方式发送数据\r\nxhr.send(\"username=\" + uname + \"\u0026password=\" + pw); \r\n*/\r\n\r\n4. 指定回调函数\r\n//这个回调函数主要用来检测服务器是否把数据返回给异步对象\r\nxhr.onreadystatechange = function() {\r\n//readyState属性指出了XMLHttpRequest对象在发送/接收数据过程中所处的几个状态。XMLHttpRequest对象会经历5种不同的状态。\r\n//0：未初始化。对象已经创建，但还未初始化，即还没调用open方法；\r\n//1：已打开。对象已经创建并初始化，但还未调用send方法；\r\n//2：已发送。已经调用send 方法，但该对象正在等待状态码和头的返回；\r\n//3：正在接收。已经接收了部分数据，但还不能使用该对象的属性和方法，因为状态和响应头不完整；\r\n//4：已加载。所有数据接收完毕\r\n    if (xhr.readyState == 4) { //检测服务器返回的响应报文的状态码是否为200\r\n        if (xhr.status == 200) { //当readyState为4的时候，就会有一个属性产生 --- xhr.status表示的是请求的文件的状态码\r\n            alert(xhr.responseText);\r\n            /*\r\n            1**  ----  消息\r\n            2**  ----  代码请求成功\r\n            3**  ----  重定向\r\n            4**  ----  请求错误\r\n            5**  ----  服务器错误\r\n            6**  ----  其它\r\n            */\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n### Ajax封装\r\n```\r\nfunction myAjax(obj) {\r\n    var r_type = obj.type || 'GET'; //请求方式默认GET\r\n    var url = obj.url || ''; //请求的URL\r\n    var fnsuccess = obj.success; //成功回调函数\r\n    var fnFailed = obj.error || null; //失败回调函数\r\n    var data_format = obj.dataType || 'json'; //返回数据格式默认json\r\n    var data_info = null; //发送的数据\r\n    var tmp_str = '\u0026';\r\n    if (url == \"\") {\r\n        alert('error:url is empty!');\r\n        return false;\r\n    }\r\n\r\n    //URL拼接参数\r\n    for (var i in obj.data) {\r\n        if (obj.data.hasOwnProperty(i)) {\r\n            if (typeof obj.data[i] !== undefined) {\r\n                tmp_str += i + \"=\" + obj.data[i] + \"\u0026\";\r\n            }\r\n        }\r\n    }\r\n\r\n    if (r_type.toUpperCase() == \"GET\") {\r\n        if (url.indexOf('?') !== -1 \u0026\u0026 url.indexOf('=') !== -1) {\r\n            url += tmp_str.slice(0, -1); //从第一个字符串开始截取\r\n        } else {\r\n            url += '?' + tmp_str.slice(1, -1); //从第二个开始截取\r\n        }\r\n    } else { //post方式\r\n        data_info = tmp_str.slice(1, -1); //user=zw\u0026age=26的形式\r\n    }\r\n    tmp_str = null; //销毁变量\r\n    //1 创建对象\r\n    var xhr = null;\r\n    if (window.ActiveXObject) {\r\n        xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); //IE下\r\n    } else if (window.XMLHttpRequest) {\r\n        xhr = new XMLHttpRequest(); //FF\r\n    }\r\n\r\n    //2 打开连接\r\n    //判断是POST,GET发送请求方式\r\n    xhr.open(r_type.toUpperCase(), url, true);\r\n    if (r_type.toUpperCase() == \"POST\") {\r\n        //设置响应头信息setRequestHeader();\r\n        xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\r\n    }\r\n\r\n    //3 发送请求\r\n    xhr.send(data_info || null);\r\n    //4 服务器处理请求后给客户端，回调函数处理\r\n    xhr.onreadystatechange = function() {\r\n        if (xhr.readyState == 4) {\r\n            //对象状态码表示完成响应内容解析完成，可以在客户端调用\r\n            //服务器返回状态码\r\n            if (xhr.status == 200) {\r\n                //整个过程请求成功\r\n                //alert(xhr.responseText);\r\n                //接收xhr.responseText作为参数\r\n                if (data_format == \"html\" || data_format == \"json\") {\r\n                    fnsuccess \u0026\u0026 fnsuccess(xhr.responseText);\r\n                } else {\r\n                    fnsuccess \u0026\u0026 fnsuccess(xhr.responseXML);\r\n                }\r\n            } else {\r\n                //请求失败，404表示找不到\r\n                //alert(\"error status:\"+xhr.status);\r\n                //失败调用函数\r\n                if (fnFailed) {\r\n                    fnFailed(xhr.status);\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n### jQuery的ajax方法\r\n```\r\n$.ajax({\r\n    type: \"method\",\r\n    url: \"url\",\r\n    data: \"data\",\r\n    dataType: \"dataType\",\r\n    success: function (response) {\r\n        console.log(response);\r\n    }\r\n});\r\n\r\n$.get(\"url\", data,\r\n    function (data, textStatus, jqXHR) {\r\n        \r\n    },\r\n    \"dataType\"\r\n);\r\n\r\n$.post(\"url\", data,\r\n    function (data, textStatus, jqXHR) {\r\n        \r\n    },\r\n    \"dataType\"\r\n);\r\n```\r\n\r\n### json数据解析\r\n- 把JSON文本转换为JavaScript对象\r\n\r\n\t\u003e JSON 最常见的用法之一，是从 web 服务器上读取 JSON 数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript 对象，然后在网页中使用该数据。\r\n\r\n- 为什么要转换\r\n\r\n\t\u003e在数据传输过程中，json是以文本，即字符串的形式传递的，而JS操作的是JSON对象，所以，JSON对象和JSON字符串之间的相互转换是关键。\r\n\r\n- 转换的方法\r\n\r\n\t- JSON.parse()\t     --- 把json形式的字符串转成对象\r\n\t- JSON.stringify()   --- 把对象转成字符串\r\n\t- eval() \t\t\t --- 把字符串解析成JS代码并执行\r\n\r\n- php开发json形式数据接口\r\n\r\n    - json_encode() --- 把数组转换成JSON形式的字符串","cover":"/images/ajax.png","link":"ajax总结.html","preview":"\u003cp\u003eAjax的介绍以及使用方法。\u003c/p\u003e\n","title":"Ajax总结"},{"content":"\r\n\r\n\u003c!-- TOC --\u003e\r\n\r\n- [安装](#安装)\r\n- [罗列可以使用的starter项目](#罗列可以使用的starter项目)\r\n- [安装webpack-simple类型的starter](#安装webpack-simple类型的starter)\r\n- [安装webpack类型的starter](#安装webpack类型的starter)\r\n\r\n\u003c!-- /TOC --\u003e\r\n\r\n## 安装\r\n```\r\nnpm install -g vue-cli\r\n```\r\n\r\n## 罗列可以使用的starter项目\r\n```\r\nvue list\r\n```\r\n\r\n```\r\nC:\\Users\\Administrator\u003evue list\r\n\r\n  Available official templates:\r\n\r\n  ★  browserify - A full-featured Browserify + vueify setup with hot-reload, linting \u0026 unit testing.\r\n  ★  browserify-simple - A simple Browserify + vueify setup for quick prototyping.\r\n  ★  simple - The simplest possible Vue setup in a single HTML file\r\n  ★  webpack - A full-featured Webpack + vue-loader setup with hot reload, linting, testing \u0026 css extraction.\r\n  ★  webpack-simple - A simple Webpack + vue-loader setup for quick prototyping.\r\n\r\n```\r\n\r\n## 安装webpack-simple类型的starter\r\n```\r\nvue init webpack-simple myApp\r\n```\r\n\r\n## 安装webpack类型的starter\r\n```\r\nvue init webpack myApp\r\n```","cover":"/images/vue.jpg","link":"vue cli使用总结.html","preview":"\u003cp\u003evue项目脚手架\u003c/p\u003e\n","title":"vue cli使用总结"},{"content":"\r\n\r\n\u003c!-- TOC --\u003e\r\n\r\n- [学习目标](#学习目标)\r\n- [学习建议](#学习建议)\r\n- [相关代码下载地址](#相关代码下载地址)\r\n- [从angular 1.x中学到的概念review](#从angular-1x中学到的概念review)\r\n    - [框架与库的区别](#框架与库的区别)\r\n    - [SPA与多页面的区别](#spa与多页面的区别)\r\n    - [mvc,mvvm](#mvcmvvm)\r\n    - [mvc和mvvm的作用：](#mvc和mvvm的作用)\r\n    - [如何安装angular.js](#如何安装angularjs)\r\n    - [数据绑定之单向数据绑定](#数据绑定之单向数据绑定)\r\n    - [双向数据绑定](#双向数据绑定)\r\n    - [$watch](#watch)\r\n    - [filter过滤器](#filter过滤器)\r\n    - [指令](#指令)\r\n    - [自定义指令](#自定义指令)\r\n        - [示例](#示例)\r\n        - [常见属性](#常见属性)\r\n    - [ngRoute路由](#ngroute路由)\r\n    - [todoMVC的实现思路](#todomvc的实现思路)\r\n- [vue基础知识](#vue基础知识)\r\n    - [说明](#说明)\r\n    - [谁在用](#谁在用)\r\n    - [安装](#安装)\r\n    - [chrome相关插件](#chrome相关插件)\r\n        - [使用注意](#使用注意)\r\n    - [visual studio code编辑器相关插件](#visual-studio-code编辑器相关插件)\r\n    - [vue的特点](#vue的特点)\r\n    - [hello world](#hello-world)\r\n        - [示例](#示例-1)\r\n    - [讲解](#讲解)\r\n        - [注意事项](#注意事项)\r\n    - [单次绑定](#单次绑定)\r\n    - [实现值加1](#实现值加1)\r\n    - [实现值加1升级版](#实现值加1升级版)\r\n    - [为什么vue的性能这么高？](#为什么vue的性能这么高)\r\n    - [双向数据绑定的原理](#双向数据绑定的原理)\r\n    - [表单控件](#表单控件)\r\n    - [v-bind指令](#v-bind指令)\r\n    - [watch监视](#watch监视)\r\n    - [计算属性](#计算属性)\r\n        - [用计算属性替代监视](#用计算属性替代监视)\r\n        - [用计算属性替代filter](#用计算属性替代filter)\r\n    - [v-bind:class](#v-bindclass)\r\n    - [v-if,v-else](#v-ifv-else)\r\n    - [v-show](#v-show)\r\n    - [v-for](#v-for)\r\n    - [v-cloak](#v-cloak)\r\n    - [事件处理器 v-on](#事件处理器-v-on)\r\n    - [事件对象event](#事件对象event)\r\n    - [修饰符](#修饰符)\r\n    - [组件](#组件)\r\n        - [组件使用注意事项](#组件使用注意事项)\r\n    - [子组件向父组件要数据](#子组件向父组件要数据)\r\n    - [slot](#slot)\r\n    - [vue-cli](#vue-cli)\r\n    - [开启debug模式](#开启debug模式)\r\n    - [是否开启HTML5的history模式,开启后，需服务器端支持，否则报404](#是否开启html5的history模式开启后需服务器端支持否则报404)\r\n    - [vue-router的钩子函数](#vue-router的钩子函数)\r\n\r\n\u003c!-- /TOC --\u003e\r\n## 学习目标\r\n- 熟悉常见的vue.js框架的API\r\n- 了解如何安装使用单文件组件\r\n- 能自己完成todoMVC项目\r\n\r\n## 学习建议\r\n- 课程中使用的是v2.1.6版本\r\n- 如果网上找的教程或书的代码执行不了，很正常，因为过时了\r\n\r\n## 相关代码下载地址\r\n[下载地址](https://github.com/black-pony/learn_vue_the_hard_way)\r\n\r\n\r\n## 从angular 1.x中学到的概念review\r\n### 框架与库的区别\r\n库就是一堆的工具，比如我们使用了jQuery,但是并不能改变我们以往（第一步选择元素，第二步添加事件）的思路，只不过方便了我们写代码。\r\n框架就是一套规则和规范，我们用了某框架之后，我们必须要按这套框架的规则去做，比如bootstrap,我们只要使用了bootstrap，我们按照它的教程定义一些class，就会得到一个响应式的页面。\r\n\r\n###  SPA与多页面的区别\r\n\r\n多页面应用就是一个网站里面，有一堆的页面，页面与页面之间是独立的，缺点就是当我们从一个页面跳转到另外一个页面的时候，另一个页面所有的东西全部需要从服务器加载，这样会出现白屏的现象，用户体验不好。\r\nSPA就是single page application,单页面应用，比如我们打开网易云音乐，我们点击上面的链接会发现，页面并没有跳转，只不过是hash在发生改变，我们通过js监听hashchange事件，当触发的时候，我们就去服务器加载对应的数据，然后替换掉对应的DOM区域，但是页面的主体结构并不需要变动。\r\n\r\n### mvc,mvvm\r\nmvc就是把整个代码划分成模型、视图、控制器这三大块，模型负责管理数据（增删改查），视图就是我们的模板，控制器负责连接模型和视图。\r\n1、view传送指令到controller\r\n2、controller完成业务逻辑后，要求model改变状态\r\n3、model将新的数据发送到view,用户得到反馈\r\n\r\nmvvm是把整个代码划分成模型、视图、view model三大块：\r\nmvvm采用双向数据绑定，view的变动，自动反映在view model，反之亦然。\r\n\r\n### mvc和mvvm的作用：\r\n1、解耦：让我们的代码结构比较清晰\r\n2、便于我们的维护\r\n\r\n### 如何安装angular.js\r\n1、暴力安装\r\n2、通过bower安装(淘汰了)\r\n3、npm安装\r\n4、cdn安装\r\n\r\n### 数据绑定之单向数据绑定\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n    \u003cstyle\u003e\r\n        div{\r\n            width: 200px;\r\n            height: 40px;\r\n            line-height: 40px;\r\n            outline: 1px solid green;\r\n        }\r\n    \u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody ng-app=\"myApp\" ng-controller=\"myController\"\u003e\r\n    \u003c!--当我们修改下面的div的值的时候，不会影响model里面message值--\u003e\r\n    \u003cdiv contenteditable \u003e{{message}}\u003c/div\u003e\r\n    \u003cscript src=\"./node_modules/angular/angular.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        window.onload= function(){\r\n            document.getElementsByTagName(\"div\")[0].focus()\r\n        };\r\n        var myApp = angular.module('myApp',[]);\r\n        myApp.controller('myController',['$scope',function($scope){\r\n            $scope.message = 'Hello world';\r\n        }]);\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n### 双向数据绑定\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n    \u003cstyle\u003e\r\n        div{\r\n            width: 200px;\r\n            height: 40px;\r\n            line-height: 40px;\r\n            outline: 1px solid green;\r\n        }\r\n    \u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody ng-app=\"myApp\" ng-controller=\"myController\"\u003e\r\n    \u003c!--当我们修改下面的input的值的时候，会影响model里面message值--\u003e\r\n    \u003cinput type=\"text\" ng-model=\"message\"\u003e\r\n    \u003cdiv contenteditable \u003e{{message}}\u003c/div\u003e\r\n    \u003cscript src=\"./node_modules/angular/angular.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        window.onload= function(){\r\n            document.getElementsByTagName(\"input\")[0].focus()\r\n        };\r\n        var myApp = angular.module('myApp',[]);\r\n        myApp.controller('myController',['$scope',function($scope){\r\n            $scope.message = 'Hello world';\r\n        }]);\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### $watch\r\n\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n    \u003cstyle\u003e\r\n        div{\r\n            width: 200px;\r\n            height: 40px;\r\n            line-height: 40px;\r\n            outline: 1px solid green;\r\n        }\r\n    \u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody ng-app=\"myApp\" ng-controller=\"myController\"\u003e\r\n    \u003c!--当我们修改下面的input的值的时候，会影响model里面message值--\u003e\r\n    \u003cinput type=\"text\" ng-model=\"message\"\u003e\r\n    \u003cscript src=\"./node_modules/angular/angular.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        window.onload= function(){\r\n            document.getElementsByTagName(\"input\")[0].focus()\r\n        };\r\n        var myApp = angular.module('myApp',[]);\r\n        myApp.controller('myController',['$scope',function($scope){\r\n            $scope.message = 'Hello world';\r\n            $scope.$watch('message',function(now,prev){\r\n                console.log(now,prev);\r\n            });\r\n        }]);\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n### filter过滤器\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n    \u003cstyle\u003e\r\n        div{\r\n            width: 200px;\r\n            height: 40px;\r\n            line-height: 40px;\r\n            outline: 1px solid green;\r\n        }\r\n    \u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody ng-app=\"myApp\" ng-controller=\"myController\"\u003e\r\n    \u003c!--当我们修改下面的input的值的时候，会影响model里面message值--\u003e\r\n    {{'1484657346797'|date}}\r\n    \u003cul\u003e\r\n        \u003cli ng-repeat=\"item in arr | filter : {isTrue:true}\"\u003e{{item.name}}\u003c/li\u003e\r\n    \u003c/ul\u003e\r\n    \u003cscript src=\"./node_modules/angular/angular.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        window.onload= function(){\r\n            document.getElementsByTagName(\"input\")[0].focus()\r\n        };\r\n        var myApp = angular.module('myApp',[]);\r\n        myApp.controller('myController',['$scope',function($scope){\r\n            $scope.arr = [\r\n                {name:'itcast',isTrue:true},\r\n                {name:'heima',isTrue:false},\r\n                {name:'chuanzhi',isTrue:true},\r\n                {name:'black-pony',isTrue:false}\r\n            ];\r\n        }]);\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n### 指令\r\n- ng-app\r\n- ng-model\r\n- ng-init\r\n- ng-controller\r\n- ng-bind\r\n- ng-repeat\r\n    + $index\r\n    + $odd\r\n    + $even\r\n    + $first\r\n    + $last\r\n- ng-class\r\n- ng-style\r\n- ng-show\r\n- ng-hide\r\n- ng-if\r\n- ng-switch\r\n- ng-switch-when\r\n- ng-src\r\n- ng-href\r\n- ng-bind-html(须引入ng-sanitize模块)\r\n\r\n### 自定义指令\r\n\r\n####  示例\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n    \u003cstyle\u003e\r\n        div{\r\n            width: 200px;\r\n            height: 40px;\r\n            line-height: 40px;\r\n            outline: 1px solid green;\r\n        }\r\n    \u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody ng-app=\"myApp\" ng-controller=\"myController\"\u003e\r\n    \u003cinput type=\"text\" my-focus\u003e\r\n    \u003cscript src=\"./node_modules/angular/angular.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        var myApp = angular.module('myApp',[]);\r\n        myApp.controller('myController',['$scope',function($scope){\r\n\r\n        }]);\r\n        myApp.directive('myFocus',function(){\r\n            return {\r\n                restrict:'A',\r\n                link:function(scope,element,attributes){\r\n                    element[0].focus();\r\n                }\r\n            };\r\n        });\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n#### 常见属性\r\n- template\r\n- templateUrl\r\n- replace\r\n- restrict\r\n- transclude\r\n- scope\r\n- link\r\n\r\n### ngRoute路由\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody ng-app=\"myApp\"\u003e\r\n    \u003cdiv ng-view\u003e\u003c/div\u003e\r\n    \u003cscript src=\"./node_modules/angular/angular.js\"\u003e\u003c/script\u003e\r\n    \u003cscript src=\"./node_modules/angular-route/angular-route.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        var myApp = angular.module('myApp',['ngRoute']);\r\n        myApp.config(['$routeProvider',function($routeProvider){\r\n            $routeProvider\r\n                .when('/foo',{\r\n                    template:'\u003ch1\u003efoo\u003c/h1\u003e',\r\n                    controller:'fooController'\r\n                })\r\n                .when('/bar',{\r\n                    template:'\u003ch1\u003ebar\u003c/h1\u003e',\r\n                    controller:'fooController'\r\n                })\r\n                .otherwise({\r\n                    template:'\u003ch1\u003efoo\u003c/h1\u003e',\r\n                    controller:'fooController'\r\n                });\r\n        }]);\r\n        myApp.controller('fooController',['$scope',function($scope){\r\n\r\n        }]);\r\n        myApp.controller('barController',['$scope',function($scope){\r\n            \r\n        }]);\r\n\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n### todoMVC的实现思路\r\n- 本质上是进行数组的增删改查\r\n- 显示 --\u003e ng-repeat\r\n- 删除 --\u003e replace\r\n- 修改 --\u003e ng-class\r\n- 增加 --\u003e push\r\n\r\n## vue基础知识\r\n\r\n### 说明\r\n- 本教程采用的是vue 2.1.9,请下载这个版本的进行学习，否则可能导致API用不了或过时\r\n- 在学习阶段，不建议一上来就学习单文件组件模式\r\n\r\n### 谁在用\r\n- 阿里爸爸\r\n- 饿了吗\r\n- talking Data\r\n\r\n### 安装\r\n\u003e npm init -y\r\n\u003e  npm install -S vue@2.1.9\r\n\r\n### chrome相关插件\r\nvue-dev tools\r\n \r\n#### 使用注意\r\n 一定要在服务器环境下面使用才能点亮这个插件\r\n \r\n### visual studio code编辑器相关插件\r\n- vue\r\n- vue components\r\n- vue 2 snippets\r\n- vueHelper\r\n- vetur\r\n \r\n### vue的特点\r\n-  简单轻量的js框架\r\n- 数据驱动(自动追踪依赖的模板表达式和计算属性)\r\n- 每个组件代表独立的单元、有各自的view及数据逻辑,用可解耦、可复用的组件来构造界面,你总是应该从UI出发抽象出不同的组件，然后像搭积木一样把它们拼装起来\r\n- 最适合用来开发SPA\r\n \r\n###  hello world\r\n \r\n#### 示例\r\n```html\r\n \u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n    \u003cdiv id=\"myApp\"\u003e\r\n        \u003cinput type=\"text\" v-model=\"message\"\u003e\r\n        {{message}}\r\n    \u003c/div\u003e\r\n    \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        var vm = new Vue({\r\n            el:'#myApp',\r\n            data:{\r\n                message:'Hello world'\r\n            }\r\n        })\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### 讲解\r\n- el --\u003e 要绑定的元素，限定我们的vue项目的范围,这里可以用id，也可以用class，一般默认用id\r\n- data --\u003e 要绑定的数据模型\r\n- {{message}} --\u003e 插值表达式,可以用来获取我们的model中的数据\r\n- new Vue() --\u003e 每个vue项目都是通过构造器Vue来创建一个vue实例的\r\n- v-model --\u003e 类似ng-model,可以用来进行双向数据绑定\r\n- data --\u003e 我们的model\r\n\r\n#### 注意事项\r\n- vue不能挂载到body上面，会出现warnning警告\r\n\r\n### 单次绑定\r\n页面上的有些东西一旦赋值渲染之后，基本上不太可能会变动了，比如像我们的图片的url,像链接的href值，这个时候，我们可以使用单次绑定\r\n\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n    \u003cdiv class=\"myApp\"\u003e\r\n        \u003cinput type=\"text\" v-model=\"message\"\u003e\r\n        \u003cdiv v-once\u003e\r\n            {{message}}\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        var vm = new Vue({\r\n            el:'.myApp',\r\n            data:{\r\n                message:'Hello world'\r\n            }\r\n        })\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### 实现值加1\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n    \u003cdiv class=\"myApp\"\u003e\r\n        \u003cinput type=\"button\" v-on:click=\"counter = (counter - 0) + 1\" v-model=\"counter\"\u003e\r\n    \u003c/div\u003e\r\n    \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        var vm = new Vue({\r\n            el:'.myApp',\r\n            data:{\r\n                counter:1\r\n            }\r\n        })\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### 实现值加1升级版\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n    \u003cdiv class=\"myApp\"\u003e\r\n        \u003cinput type=\"button\" v-on:click=\"add\" v-model=\"counter\"\u003e\r\n    \u003c/div\u003e\r\n    \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        var vm = new Vue({\r\n            el:'.myApp',\r\n            data:{\r\n                counter:1\r\n            },\r\n            methods:{\r\n                add:function(){\r\n                    this.counter++;\r\n                }\r\n            }\r\n        })\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### 为什么vue的性能这么高？\r\n实现双向数据绑定，目前主要有三种方式：脏检查、观察机制、封装属性访问器\r\n\r\n- 脏检查：框架将所有需要监控的属性放在一个队列中，当发生特定事件时，我们的框架只要觉得当前这个数据有可能变脏了，它就会遍历整个序列，对被监控的属性做对比，如果发生变化，则调用相应的处理函数。(angular实现了一套类似我们的原生的js的一套event loop)\r\nangular 1.x的双向数据绑定是自己实现出来一套event loop机制，通过apply,watch list监听数据的变化，一旦它认为你的model变了，也就是变“脏”了，就去重新执行一轮event loop,进行脏值检测，所以效率很低。\r\n![](http://ojmkbnynx.bkt.clouddn.com/17-1-17/33059309-file_1484661229826_df58.png)\r\n\r\n- 观察机制：通过 Object.observe() 「已废弃」方法对对象进行监控，一旦其发生变化，将会执行相应的handler。\r\n- 封装属性访问器：使用 Object.defineProperty 将对象的属性转换为 getter/setter ，当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。\r\nvue.js使用的就是这种方式（当然不支持IE8）\r\n\r\n### 双向数据绑定的原理\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n    \u003cdiv id=\"myApp\"\u003e\r\n        \u003cinput type=\"text\" eric-model=\"message\"\u003e\r\n        \u003cinput type=\"text\" eric-model=\"message\"\u003e\r\n        \u003cdiv\u003e\r\n            \u003cdiv\u003e{{message}}\u003c/div\u003e\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cscript\u003e\r\n        var vm = {};\r\n        Object.defineProperty(vm,'message',{\r\n            val:null,\r\n            get:function(){\r\n                this.val = this.val || '';\r\n                return this.val;\r\n            },\r\n            set:function(val){\r\n                this.val = val;\r\n                refresh_view();\r\n            }\r\n        });\r\n        var el = document.querySelector('#myApp');\r\n\r\n        //初始化视图\r\n        function init_view(){\r\n            var list = el.getElementsByTagName('*');\r\n            var reg1 = /\u003c.*\u003e/g;\r\n            var reg2 = /{{(.*)}}/;\r\n            for(var i=0;i\u003clist.length;i++){\r\n                // console.log(list[i].innerHTML);\r\n                if(list[i].tagName!='INPUT' \u0026\u0026 !reg1.test(list[i].innerHTML) \u0026\u0026 reg2.test(list[i].innerHTML)){\r\n                    var myBind = reg2.exec(list[i].innerHTML)[1];\r\n                    list[i].setAttribute('myBind',myBind);\r\n                    // console.log(list[i].getAttribute('myBind'))\r\n                    list[i].innerHTML = vm[list[i].getAttribute('myBind')];\r\n                }\r\n                if(list[i].tagName === 'INPUT' \u0026\u0026 list[i].getAttribute('eric-model')){\r\n                    var myBind = list[i].getAttribute('eric-model');\r\n                    list[i].value = vm[list[i].getAttribute('eric-model')];\r\n                }\r\n            }\r\n        }\r\n\r\n        init_view();\r\n\r\n        function refresh_view(){\r\n            var list = el.getElementsByTagName('*');\r\n            for(var i=0;i\u003clist.length;i++){\r\n                if(list[i].getAttribute('myBind')){\r\n                    list[i].innerHTML = vm[list[i].getAttribute('myBind')];\r\n                }\r\n                if(list[i].getAttribute('eric-model') \u0026\u0026 list[i].tagName === 'INPUT'){\r\n                    list[i].value = vm[list[i].getAttribute('eric-model')];\r\n                }\r\n            }\r\n        }\r\n\r\n        var modelEleList = document.querySelectorAll('input[eric-model]');\r\n        console.log(modelEleList);\r\n        for(var i=0;i\u003cmodelEleList.length;i++){\r\n            modelEleList[i].addEventListener('input',function(){\r\n                var myBind = this.getAttribute('eric-model');\r\n                vm[myBind] = this.value;\r\n            },false);\r\n        }\r\n\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### 表单控件\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"form-input\"\u003e\r\n    \u003cspan\u003emessage is {{message}}\u003c/span\u003e\r\n    \u003cbr\u003e\r\n    \u003cinput type=\"text\" v-model=\"message\"\u003e\r\n  \u003c/div\u003e\r\n  \u003chr\u003e\r\n  \u003cdiv class=\"form-chkbox\"\u003e\r\n    \u003cinput type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"\u003e\r\n    \u003clabel for=\"checkbox\"\u003e{{checked}}\u003c/label\u003e\r\n  \u003c/div\u003e\r\n  \u003chr\u003e\r\n  \u003cdiv class=\"form-chkboxes\"\u003e\r\n   \u003cinput type=\"checkbox\" id=\"jack\" v-model=\"checkedNames\" value=\"jack\"\u003e\r\n   \u003cinput type=\"checkbox\" id=\"john\" v-model=\"checkedNames\" value=\"john\"\u003e\r\n    \u003cbr\u003e\r\n    message:{{checkedNames | json}}\r\n  \u003c/div\u003e\r\n  \u003chr\u003e\r\n  \u003cdiv class=\"form-radio\"\u003e\r\n    \u003clabel for=\"one\"\u003eone\u003c/label\u003e\r\n    \u003cbr\u003e\r\n    \u003cinput type=\"radio\" id=\"one\" value=\"one\" v-model=\"picked\"\u003e\r\n    \u003cbr\u003e\r\n    \u003clabel for=\"two\"\u003etwo\u003c/label\u003e\r\n    \u003cinput type=\"radio\" value=\"two\" v-model=\"picked\"\u003e\r\n    \u003cbr\u003e\r\n    \u003cspan\u003ePicked:{{picked}}\u003c/span\u003e\r\n  \u003c/div\u003e\r\n  \u003chr\u003e\r\n  \u003cdiv class=\"form-select\"\u003e\r\n    \u003cselect v-model=\"selected\"\u003e\r\n      \u003coption\u003eA\u003c/option\u003e\r\n      \u003coption selected\u003eB\u003c/option\u003e\r\n      \u003coption\u003eC\u003c/option\u003e\r\n    \u003c/select\u003e\r\n    \u003cbr\u003e\r\n    \u003cspan\u003eselected:{{selected}}\u003c/span\u003e\r\n  \u003c/div\u003e\r\n  \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n  \u003cscript\u003e\r\n   new Vue({\r\n     el:\".form-input\",\r\n     data:{\r\n       message:\"\"\r\n     }\r\n   });\r\n   new Vue({\r\n     el:\".form-chkbox\",\r\n     data:{\r\n       checked:false\r\n     }\r\n   });\r\n   new Vue({\r\n     el:\".form-chkboxes\",\r\n     data:{\r\n       checkedNames:[]\r\n     }\r\n   });\r\n   new Vue({\r\n     el:\".form-radio\",\r\n     data:{\r\n       picked:''\r\n     }\r\n   });\r\n   new Vue({\r\n     el:\".form-select\",\r\n     data:{\r\n       selected:''\r\n     }\r\n   });\r\n  \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### v-bind指令\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n    \u003cdiv id=\"myApp\"\u003e\r\n        \u003cinput type=\"text\" v-bind=\"{id:myId,myAttr:myAttr,value:myValue}\"\u003e\r\n        \u003cimg v-bind:src=\"myImgSrc\"\u003e\r\n        \u003cimg :src=\"myImgSrc\"\u003e\r\n        \u003ca v-bind:href=\"myUrl\"\u003e百度\u003c/a\u003e\r\n        \u003ca :href=\"myUrl\"\u003e百度\u003c/a\u003e\r\n    \u003c/div\u003e\r\n    \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        var vm = new Vue({\r\n            el:'#myApp',\r\n            data:{\r\n                myId:'demo',\r\n                myAttr:'demoAttr',\r\n                myValue:'wfewf',\r\n                myImgSrc:'http://i0.hdslb.com/bfs/archive/ac6ad98e868f313a332eb757634ddc9fcd5d7753.jpg@.webp',\r\n                myUrl:'http://baidu.com',\r\n            }\r\n        });\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n### watch监视\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n    \u003cdiv id=\"myApp\"\u003e\r\n       \u003cinput type=\"text\" v-model=\"message1\"\u003e\r\n       \u003cinput type=\"text\" v-model=\"message2\"\u003e\r\n    \u003c/div\u003e\r\n    \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        var vm = new Vue({\r\n            el:'#myApp',\r\n            data:{\r\n                message1:'hello1',\r\n                message2:'hello2'\r\n            },  \r\n            watch:{\r\n                message1:function(now,pre){\r\n                    console.log(now,pre);\r\n                }\r\n            }\r\n        });\r\n        vm.$watch('message2',function(now,pre){\r\n            console.log(now,pre);\r\n        })\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### 计算属性\r\nvue在2.1.5(大概这个版本，记不太清了)的时候，曾经取消了监视，因为作者发现，完全可以采用计算属性来实现：\r\n#### 用计算属性替代监视\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n    \u003cdiv id=\"myApp\"\u003e\r\n       \u003cinput type=\"text\" v-model=\"a\"\u003e\r\n       \u003cinput type=\"text\" v-model=\"b\"\u003e\r\n       \u003cinput type=\"text\" v-model=\"result\"\u003e\r\n    \u003c/div\u003e\r\n    \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        var vm = new Vue({\r\n            el:'#myApp',\r\n            data:{\r\n                a:0,\r\n                b:0\r\n            },  \r\n            computed:{\r\n                result:function(){\r\n                    return Number(this.a) + Number(this.b);\r\n                }\r\n            }\r\n        });\r\n        vm.$watch('message2',function(now,pre){\r\n            console.log(now,pre);\r\n        })\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n#### 用计算属性替代filter\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n    \u003cdiv id=\"myApp\"\u003e\r\n       \u003cul\u003e\r\n           \u003cli v-for=\"item in arr1\"\u003e{{item}}\u003c/li\u003e\r\n       \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n    \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n    \u003cscript\u003e\r\n        var vm = new Vue({\r\n            el:'#myApp',\r\n            data:{\r\n                arr:[2,3,4,5,6]\r\n            },  \r\n            computed:{\r\n                arr1:function(){\r\n                    return this.arr.filter(function(item){return item \u003e 4});\r\n                }\r\n            }\r\n        });\r\n        vm.$watch('message2',function(now,pre){\r\n            console.log(now,pre);\r\n        })\r\n    \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### v-bind:class\r\n使用原则：静态的class放在HTML的class特效内，而动态的应该使用v-bind:class\r\n```html\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv id=\"demo\"\u003e\r\n    \u003cdiv v-bind:class=\"{red:isRed}\"\u003e11\u003c/div\u003e\r\n    \u003cdiv v-bind:class=\"{a,b}\"\u003e111\u003c/div\u003e\r\n    \u003cdiv v-bind:class=\"[c,{d:isD,e:isE}]\"\u003e111\u003c/div\u003e\r\n    \u003c!--绑定style--\u003e\r\n    \u003cdiv v-bind:style=\"{fontSize:size + 'px'}\"\u003e111\u003c/div\u003e\r\n    \u003cdiv v-bind:style=\"{{width:'100px'},styleObjectB}\"\u003e11\u003c/div\u003e\r\n  \u003c/div\u003e\r\n  \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n  \u003cscript\u003e\r\n    var app = new Vue({\r\n      el:\"#demo\",\r\n      data:{\r\n        isRed:true,\r\n        size:20,\r\n        a:true,\r\n        b:false,\r\n        c:\"world\",\r\n        isD:true,\r\n        isE:true,\r\n        styleObjectA:{\r\n          color:'red',\r\n          fontSize:'13px'\r\n        },\r\n        styleObjectB:{\r\n          backgroundColor:'cyan'\r\n        }\r\n      }\r\n    });\r\n  \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### v-if,v-else\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv id=\"demo\"\u003e\r\n    \u003clabel for=\"one\"\u003eone\u003c/label\u003e\r\n    \u003cinput type=\"radio\" id=\"one\" v-model=\"picked\" value=\"one\"\u003e\r\n    \u003clabel for=\"two\"\u003etwo\u003c/label\u003e\r\n    \u003cinput type=\"radio\" id=\"two\" v-model=\"picked\" value=\"two\"\u003e\r\n    \u003cdiv v-if=\"picked==='one'\"\u003eyes\u003c/div\u003e\r\n    \u003cdiv v-else\u003eNo\u003c/div\u003e\r\n  \u003c/div\u003e\r\n  \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n  \u003cscript\u003e\r\n    var app = new Vue({\r\n      el:\"#demo\",\r\n      data:{\r\n        picked:'one'\r\n      }\r\n    });\r\n  \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n### v-show\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv id=\"demo\"\u003e\r\n    \u003clabel for=\"one\"\u003eone\u003c/label\u003e\r\n    \u003cinput type=\"radio\" id=\"one\" v-model=\"picked\" value=\"one\"\u003e\r\n    \u003clabel for=\"two\"\u003etwo\u003c/label\u003e\r\n    \u003cinput type=\"radio\" id=\"two\" v-model=\"picked\" value=\"two\"\u003e\r\n    \u003cdiv v-show=\"picked==='one'\"\u003eyes\u003c/div\u003e\r\n    \u003cdiv v-show=\"picked!='one'\"\u003eNo\u003c/div\u003e\r\n  \u003c/div\u003e\r\n  \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n  \u003cscript\u003e\r\n    var app = new Vue({\r\n      el:\"#demo\",\r\n      data:{\r\n        picked:'one'\r\n      }\r\n    });\r\n  \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### v-for\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv id=\"demo\"\u003e\r\n    \u003c!--数组的迭代--\u003e\r\n    \u003cul\u003e\r\n      \u003cli v-for=\"(item,index) in arr\"\u003e{{item}} - {{index}}\u003c/li\u003e\r\n    \u003c/ul\u003e\r\n    \u003c!--对象的迭代--\u003e\r\n    \u003cul\u003e\r\n      \u003cli v-for=\"(value,key) in obj\"\u003e{{key}} - {{value}}\u003c/li\u003e\r\n    \u003c/ul\u003e\r\n    \u003c!--vue特有的迭代--\u003e\r\n    \u003cul\u003e\r\n    \u003cli v-for=\"n in 10\"\u003e{{n}}\u003c/li\u003e\r\n    \u003c/ul\u003e\r\n  \u003c/ul\u003e\r\n  \u003c/div\u003e\r\n  \u003cscript src=\"vue.js\"\u003e\u003c/script\u003e\r\n  \u003cscript\u003e\r\n    var app = new Vue({\r\n      el:\"#demo\",\r\n      data:{\r\n        arr:[2,3,4],\r\n        obj:{name:\"eric zheng\",sex:\"male\"}\r\n      }\r\n    });\r\n  \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### v-cloak\r\n配合[v-cloak] { display: none }使用，类似angular的ng-cloak\r\n\r\n### 事件处理器 v-on\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv id=\"demo\"\u003e\r\n    \u003cinput type=\"button\" v-on:click=\"fn\" value=\"v-on:click点击触发\"\u003e\r\n    \u003cinput type=\"button\" @click=\"fn\" value=\"@click点击触发\"\u003e\r\n  \u003c/div\u003e\r\n  \u003cscript src=\"vue.js\"\u003e\u003c/script\u003e\r\n  \u003cscript\u003e\r\n    var app = new Vue({\r\n      el:\"#demo\",\r\n      data:{\r\n        arr:[2,3,4],\r\n        obj:{name:\"eric zheng\",sex:\"male\"}\r\n      },\r\n      methods:{\r\n        fn:function(){\r\n          alert(\"被点击了\");\r\n        }\r\n      }\r\n    });\r\n  \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### 事件对象event\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv id=\"demo\"\u003e\r\n    \u003cinput type=\"button\" v-on:click=\"fn\" value=\"v-on:click点击触发\"\u003e\r\n    \u003cinput type=\"button\" @click=\"fn\" value=\"@click点击触发\"\u003e\r\n  \u003c/div\u003e\r\n  \u003cscript src=\"vue.js\"\u003e\u003c/script\u003e\r\n  \u003cscript\u003e\r\n    var app = new Vue({\r\n      el:\"#demo\",\r\n      data:{\r\n        arr:[2,3,4],\r\n        obj:{name:\"eric zheng\",sex:\"male\"}\r\n      },\r\n      methods:{\r\n        fn:function(event){\r\n          console.log(event.target);\r\n        }\r\n      }\r\n    });\r\n  \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### 修饰符\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv id=\"demo\"\u003e\r\n    \u003cinput type=\"button\" v-on:click=\"fn\" value=\"v-on:click点击触发\"\u003e\r\n    \u003c!--相当于写了stopPropagation--\u003e\r\n    \u003cinput type=\"button\" v-on:click.stop=\"fn\" value=\"v-on:click点击触发\"\u003e\r\n    \u003c!--相当于写了preventDefault--\u003e\r\n    \u003cinput type=\"button\" v-on:click.prevent=\"fn\" value=\"v-on:click点击触发\"\u003e\r\n    \u003c!--既阻止冒泡还阻止事件默认行为--\u003e\r\n     \u003cinput type=\"button\" v-on:click.prevent.stop=\"fn\" value=\"v-on:click点击触发\"\u003e\r\n  \u003c/div\u003e\r\n  \u003cscript src=\"vue.js\"\u003e\u003c/script\u003e\r\n  \u003cscript\u003e\r\n    var app = new Vue({\r\n      el:\"#demo\",\r\n      data:{\r\n        arr:[2,3,4],\r\n        obj:{name:\"eric zheng\",sex:\"male\"}\r\n      },\r\n      methods:{\r\n        fn:function(event){\r\n          console.log(event.target);\r\n        }\r\n      }\r\n    });\r\n  \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### 组件\r\n我们在angular当中，可以通过自定义指令来实现在页面上自定义一些元素标签，但是在vue当中，是通过组件的形式来实现的,组件是vue最主要也是最强大的特性之一，它提供了HTML元素的扩充性，也将程序代码封装起来以便开发者重复使用。\r\n\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv id=\"app\"\u003e\r\n    \u003ccustom-header\u003e\u003c/custom-header\u003e\r\n    \u003ccustom-main\u003e\u003c/custom-main\u003e\r\n  \u003c/div\u003e\r\n  \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n  \u003cscript\u003e\r\n   var app = new Vue({\r\n     el:'#app',\r\n     components:{\r\n       CustomHeader:Vue.extend({\r\n         template:'\u003cdiv class=\"header\"\u003eheader组件\u003c/div\u003e'\r\n       }),\r\n       CustomMain:Vue.extend({\r\n         template:`\r\n          \u003cul\u003e\r\n            \u003cli\u003e\u003ccustom-block\u003e\u003c/custom-block\u003e\u003c/li\u003e\r\n            \u003cli\u003e\u003ccustom-block\u003e\u003c/custom-block\u003e\u003c/li\u003e\r\n            \u003cli\u003e\u003ccustom-block\u003e\u003c/custom-block\u003e\u003c/li\u003e\r\n            \u003cli\u003e\u003ccustom-block\u003e\u003c/custom-block\u003e\u003c/li\u003e\r\n            \u003cli\u003e\u003ccustom-block\u003e\u003c/custom-block\u003e\u003c/li\u003e\r\n          \u003c/ul\u003e\r\n         `,\r\n         components:{\r\n           CustomBlock:Vue.extend({\r\n             template:'\u003ch1\u003eHello world\u003c/h1\u003e'\r\n           })\r\n         }\r\n       })\r\n\r\n     }\r\n   });\r\n  \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n#### 组件使用注意事项\r\n![](http://ojmkbnynx.bkt.clouddn.com/17-1-17/89984038-file_1484668060104_e92a.png)\r\n\r\n### 子组件向父组件要数据\r\n类似咱们angular中的自定义指令的scope\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv id=\"demo\"\u003e\r\n    \u003cchild :number=\"arr\"\u003e\u003c/child\u003e\r\n  \u003c/div\u003e\r\n  \u003cscript src=\"./node_modules/vue/dist/vue.js\"\u003e\u003c/script\u003e\r\n  \u003cscript\u003e\r\n    new Vue({\r\n      el:\"#demo\",\r\n      data:{\r\n        arr:[2,3,4,5,6]\r\n      },\r\n      components:{\r\n        child:Vue.extend({\r\n          template:\"\u003cdiv\u003e\u003cdiv v-for='item in number'\u003e{{item}}\u003c/div\u003e\u003c/div\u003e\",\r\n          props:{//props就是element上的attrs,换个名字property,变成复数 自定义属性的属性校验\r\n            number:Array//这里指定需要的数据类型，如果写错了，控制台会有错误警告\r\n          }\r\n        })\r\n      }\r\n    });\r\n  \u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n### slot\r\n允许外部环境插入内容到组件的视图结构内\r\n比如子组件为：\r\n\r\n```html\r\n\u003cdiv\u003e\r\n    \u003ch1\u003e提示\u003c/h1\u003e\r\n    \u003cslot name=\"content\"\u003e\u003c/slot\u003e\r\n    \u003cspan\u003e确定\u003c/span\u003e\r\n    \u003cspan\u003e取消\u003c/span\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n父组件使用子组件：\r\n\r\n```html\r\n\u003cconfirm\u003e\r\n    \u003cp slot=\"content\"\u003eHelloWorld\u003c/p\u003e\r\n\u003c/confirm\u003e\r\n```\r\n\r\n最终的渲染完成的效果为：\r\n\r\n```html\r\n\u003cdiv\u003e\r\n    \u003ch1\u003e提示\u003c/h1\u003e\r\n    \u003cp\u003ehelloWorld\u003c/p\u003e\r\n    \u003cspan\u003e确定\u003c/span\u003e\r\n    \u003cspan\u003e取消\u003c/span\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n### vue-cli\r\n第一步、安装vue-cli npm install -g vue-cli\r\n第二步、使用vue-cli初始化项目`vue init webpack-simple mydemo`\r\n第三步、切换到vue项目当中\r\n第四步、执行npm install\r\n第五步、执行npm run build编译成功项目\r\n第六步、执行npm run dev会自动开启项目在浏览器当中（默认是自动刷新的）\r\n\r\n### 开启debug模式\r\n```javascript\r\n    Vue.config.debug = true;\r\n```\r\n\r\n### 是否开启HTML5的history模式,开启后，需服务器端支持，否则报404\r\n```javascript\r\nvar router = new VueRouter({\r\n    history:true\r\n});\r\n```\r\n\r\n### vue-router的钩子函数\r\n- beforeEach 在路由切换开始时调用\r\n```javascript\r\nrouter.beforeEach(function(){\r\n    window.scrollTo(0,0);\r\n});\r\n```\r\n- afterEach 在路由成功切换到激活状态时调用\r\n```javascript\r\nrouter.afterEach(function(transition){\r\n    console.log(transition);\r\n});\r\n```\r\n- router.redirect()  在找不到路由时跳转","cover":"/images/vue.jpg","link":"vue简明教程.html","preview":"\u003cp\u003e优雅、简洁的前端框架\u003c/p\u003e\n","title":"vue简明教程"},{"content":"\r\n\r\n\u003c!-- TOC --\u003e\r\n\r\n- [四大api](#四大api)\r\n- [使用gulp的步骤](#使用gulp的步骤)\r\n- [使用gulp压缩css --\u003e gulp-cssnano 或者 gulp-cssmin](#使用gulp压缩css----gulp-cssnano-或者-gulp-cssmin)\r\n- [使用gulp合并css --\u003e gulp-concat](#使用gulp合并css----gulp-concat)\r\n- [使用gulp 压缩合并css](#使用gulp-压缩合并css)\r\n- [使用gulp压缩js --\u003e gulp-uglify](#使用gulp压缩js----gulp-uglify)\r\n- [使用gulp合并js --\u003e gulp-concat](#使用gulp合并js----gulp-concat)\r\n- [使用gulp压缩合并js --\u003e gulp-uglify + gulp-concat](#使用gulp压缩合并js----gulp-uglify--gulp-concat)\r\n- [使用gulp压缩html --\u003e gulp-htmlmin](#使用gulp压缩html----gulp-htmlmin)\r\n- [使用gulp进行监视文件的改变 --\u003e gulp.watch](#使用gulp进行监视文件的改变----gulpwatch)\r\n- [常用gulp插件](#常用gulp插件)\r\n\r\n\u003c!-- /TOC --\u003e\r\n\r\n![gulp功能一览图](/images/1245223-f1682d270e570f41.jpg)\r\n\r\n## 四大api\r\n- gulp.src 指定要处理的文件的路径\r\n\r\n```javascript\r\ngulp.src('client/templates/*.jade')\r\n    .pipe(jade())\r\n    .pipe(minify())\r\n    .pipe(gulp.dest('build'));\r\n```\r\n\r\n```javascript\r\ngulp.src('client/*.js','client/bad.js'')\r\n```\r\n\r\n- gulp.dest 指定把处理的文件放到哪个文件夹\r\n- gulp.task 指定任务名\r\n\r\n```javascript\r\ngulp.task('someTaskName',function(){\r\n\r\n});\r\n```\r\n\r\n- gulp.watch 类似于事件，当监视的文件发生改变的时候，触发后面的回调函数\r\n\r\n## 使用gulp的步骤\r\n![gulp工作流](/images/gulp-cli.png)\r\n\r\n## 使用gulp压缩css --\u003e gulp-cssnano 或者 gulp-cssmin\r\n[文档地址](https://github.com/chilijung/gulp-cssmin/)\r\n\r\n```javascript\r\nvar gulp = require('gulp');\r\nvar cssmin = require('gulp-cssmin');\r\ngulp.task('default',function(){\r\n    gulp.src('src/**/*.css')\r\n        .pipe(cssmin())\r\n        .pipe(gulp.dest('dist'));\r\n});\r\n```\r\n## 使用gulp合并css --\u003e gulp-concat\r\n\r\n```javascript\r\nvar concat = require('gulp-concat');\r\ngulp.task('scripts',function(){\r\n    gulp.src('./lib/*.js')\r\n        .pipe(concat('all.js'))\r\n        .pipe(gulp.dest('./dist/'));\r\n});\r\n```\r\n\r\n## 使用gulp 压缩合并css \r\n顺序：先合并再压缩\r\n\r\n## 使用gulp压缩js --\u003e gulp-uglify\r\n\r\n## 使用gulp合并js --\u003e gulp-concat\r\n\r\n## 使用gulp压缩合并js --\u003e gulp-uglify + gulp-concat\r\n\r\n## 使用gulp压缩html --\u003e gulp-htmlmin\r\n\r\n## 使用gulp进行监视文件的改变 --\u003e gulp.watch\r\n\r\n## 常用gulp插件\r\n\r\n插件名称 | 作用 \r\n---------|----------\r\n gulp-uglify  | js压缩\r\n gulp-minify-css | css压缩 \r\n gulp-minify-html | html压缩\r\n gulp-jshint | js代码检查\r\n gulp-concat | 文件合并\r\n gulp-less | 编译less\r\n gulp-sass | 编译sass\r\n gulp-imagemin | 压缩图片\r\n gulp-autoprefixer | css自动加前缀\r\n  ","cover":"/images/iruTC031_400x400.png","link":"gulp使用总结.html","preview":"\u003cp\u003egulp是一个用来前端的工作流构建工具。\u003c/p\u003e\n","title":"gulp总结"},{"content":"\r\n\u003c!-- TOC --\u003e\r\n\r\n- [概念理解](#概念理解)\r\n- [what is package](#what-is-package)\r\n- [what is module](#what-is-module)\r\n- [package和module的关系](#package和module的关系)\r\n- [常见命令总结](#常见命令总结)\r\n- [升级node](#升级node)\r\n    - [mac电脑](#mac电脑)\r\n    - [windows电脑](#windows电脑)\r\n- [npm用不了怎么办](#npm用不了怎么办)\r\n- [semantic versioning](#semantic-versioning)\r\n    - [a.b.c的含义](#abc的含义)\r\n- [在package.json中的体现](#在packagejson中的体现)\r\n- [package.json说明](#packagejson说明)\r\n- [解决下载npm包慢的问题](#解决下载npm包慢的问题)\r\n    - [方式一 使用taobao源](#方式一-使用taobao源)\r\n    - [使用步骤](#使用步骤)\r\n    - [方式二 使用nrm](#方式二-使用nrm)\r\n\r\n\u003c!-- /TOC --\u003e\r\n\u003e 本文翻译自`https://docs.npmjs.com`\r\n\r\n## 概念理解\r\n- package 是一个被`package.json`描述文件或者文件夹\r\n- module  是一个可以通过`Node.js`的`require`来引用的文件或者文件夹(当然前端的直接通过script引入这里不提)\r\n\r\n## what is package\r\n- 一个包含`package.json`的文件夹\r\n- 一个已经放到`npmjs.org`上面的，可以通过`npm install --save \u003cname\u003e@\u003cversion\u003e`下载的东西\r\n\r\n## what is module\r\n- 包含`package.json`且里面带有`main`属性的的一个文件夹\r\n- 包含`index.js`的文件夹\r\n- 一个JavaScript文件\r\n\r\n## package和module的关系\r\n大部分时候我们说二者是等价的，但有一些cli工具型的package不包含main属性是作为前端工具来使用的，所以不算是module\r\n\r\n## 常见命令总结\r\n\r\n命令 | 含义 \r\n---------|----------\r\n npm init | 交互式的创建`package.json`文件\r\n npm init -y| 默认创建`package.json`文件 \r\n npm install packageName --save、-S | 安装库(框架)、node第三方包,也可以写成npm install --save packageName\r\n npm install packageName --save-dev、-D | 安装当前项目的前端构建工具等(gulp,babel)\r\n npm install -g packageName | 全局安装前端工具(browser-sync,gulp-cli,vue-cli,react-cli之类)\r\n npm uninstall -g、--save|--save-dev | 卸载包\r\n npm docs packageName | 查看某库(框架)、Node第三方包的官网、描述信息\r\n npm install -g npm@latest | 更新npm版本到最新(自己没测过，不知是否有效)\r\n npm shrinkwrap | 锁定你当前安装的npm包的版本\r\n npm ls | 打印出来所有当前电脑安装的npm包\r\n npm config list | 我主要是用来查看当前电脑所使用的源地址(registry)\r\n npm root | 打印出来当前项目文件夹的node_modules的路径\r\n npm cache clean | 清除npm的缓存\r\n npm update | 升级本地包\r\n npm outdated | 查看哪些本地包有更新的版本\r\n npm update -g packageName | 升级全局包\r\n npm outdated -g --depth=0 | 查看哪些包有更新的版本\r\n\r\n\r\n## 升级node\r\n### mac电脑\r\n\r\n```\r\nbrew install node\r\n```\r\n### windows电脑\r\n直接卸载旧的，安装最新的msi文件\r\n\r\n## npm用不了怎么办\r\n重装node的msi软件\r\n\r\n## semantic versioning\r\n### a.b.c的含义\r\n- 主版本号.次版本号.修订号\r\n- Bug修复及极其小的改动 --\u003e 增加最后一个数字 1.0.0 --\u003e 1.0.1\r\n- 添加了新的功能特性，但没有破坏旧的API --\u003e 增加中间的数字 1.0.0 --\u003e 1.1.0\r\n- 完全重构，不能向后兼容 --\u003e 增加首尾数字 1.0.0 --\u003e 2.0.0\r\n\r\n## 在package.json中的体现\r\n- 打补丁 --\u003e 1.0,1.0.x,~1.0.4\r\n- 小的改动 --\u003e 1,1.x,^1.0.4\r\n- 大的改动 --\u003e * , x\r\n\r\n![semver对照表](/images/semver.png)\r\n\r\n\r\n## package.json说明\r\n\r\n配置项 | 配置说明\r\n---------|----------\r\n name | 当前包的名字，不能超过214个字符，不能包含.,_,不能有大写字符，不能和核心模块重名，\r\n version | 当前包的版本号，在npmjs.org上面，名字@版本号一定是唯一的标识，版本号必须符合semver\r\n description | 关于当前包的功能的描述\r\n keywords | 当前包的描述的关键词，有利于在npmjs.org进行搜索的时候可以搜索出来 \r\n homepage | 当前包的官网\r\n bugs | 如果你的包有bug,别的用户可以在这里提交issue\r\n license | 指定你的包使用的证书类型\r\n author | 作者\r\n contributors | 贡献者 \r\n files | 指定你的包必须包含的一些文件\r\n bin | npm会软链接到./node_modules/.bin下面\r\n main | 指定入口文件，如果没写默认是index.js\r\n repository | 指定你的包的仓库地址\r\n scripts | 指定可以执行的脚本 \r\n config | 可以在scripts的脚本当中，通过npm_package_config_xxx变量来访问 \r\n dependencies | 依赖项\r\n devDepencies | 像一些编译coffeescript,less,sass的包都安装在这里面\r\n\r\n## 解决下载npm包慢的问题\r\n### 方式一 使用taobao源\r\n[taobao镜像](https://npm.taobao.org/)一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。\r\n### 使用步骤\r\n1. 执行`npm install -g cnpm --registry=https://registry.npm.taobao.org`\r\n2. 把以前`npm install packageName`替换成`cnpm install packageName`\r\n\r\n### 方式二 使用nrm\r\n1. 执行`npm install -g nrm`\r\n2. 执行`nrm test`测试哪个镜像源下载速度最快\r\n```\r\nC:\\Users\\Administrator\u003enrm test\r\n\r\n*  npm ---- Fetch Error\r\n  cnpm --- 364ms\r\n  taobao - 159ms\r\n  nj ----- Fetch Error\r\n  rednpm - 256ms\r\n  npmMirror  Fetch Error\r\n  edunpm - Fetch Error\r\n```\r\n3. 通过测试我们发现，taobao是快，把镜像切换到taobao\r\n```\r\nnrm use taobao\r\n```\r\n4. 以后使用的时候，还是执行`npm install packageName`,但是下载的时候默认会从淘宝镜像去下载\r\n\r\n","cover":"/images/npm.svg","link":"npm总结.html","preview":"\u003cp\u003enpm可以作为前端库(框架)的下载工具，也可以作为Node.js项目的包管理工具。\u003c/p\u003e\n","title":"npm总结"},{"content":"\n\n## 为什么要对代码进行版本控制\n\n### 场景一\n你现在去上班了，在做一个项目，你按照产品的需要说明完成了功能，然后你拿过去给你的产品经理看，产品经理看完以后感觉有些地方不是特别的满意，然后就让你进行修改，你按产品经理的意愿回去修改了几版，但是他最后说你这一版还不如前面那一版好看，不行就用前面一版吧，但是这个时候你发现，你之前改的代码你不记得是怎么写的了~~~\n\n### 场景二\n你现在去上班了，被公司的领导分配到了一个技术小组当中，你们团队五六个人一起在开发一个项目，每个人分配到不同的需求，同时在写代码，最后你们的代码写完了，悲剧的是，你们想合并一下代码，但是由于好多文件是由很多人同时在进行修改，不知道到底要用哪个代码，害怕把对方的代码覆盖掉了~~~\n\n### 一个不太成熟的想法\n![为什么要使用版本控制软件](/images/git_01.png)\n\n### 更科学的方式\n把项目开发中的每个人的每一次微小的修改记录下来，这样可以根据记录的历史随意的切换到任意一个时间点的代码的状态：\n\n版本 | 用户 | 说明 | 日期 | 修改的代码\n---------|----------|---------|---------|---------\n 001 | zhengwei | 2016-9-1 10:20 | 添加了首页component | `import HomePage from '@/Component/HomePage.vue'`\n 002 | nll | 2016-9-1 10:22 | 添加了路由 | `Vue.use(router)`\n 003 | yevon | 2016-9-2 11:33 | 添加了ajax代码 | `created:fetch('http://localhoast:8080/getData')`\n\n### 通俗的理解\ngit就是一个时光机，我们可以随意的切换到代码的任意一个历史版本\n![](/images/timg.jpg)\n\n## 常用的版本控制软件\n\n### 按类型划分\n\n#### 集中式\n![集中式版本控制](/images/centralized.png)\n##### 常见的代表\nsvn(如果对svn感兴趣或者以后公司用得上的可以参考[svg资料](http://pan.baidu.com/s/1c2zPt9Q))\n#### 分布式\n![分布式版本控制](/images/distributed.png)\n##### 常见的代表\ngit\n\n## 集中式 vs 分布式\n- 集中式严重依赖于版本控制服务器，如果不能上网或者服务器挂了，则当前的代码不能进行版本管理，相反，分布式可以在当前的电脑进行版本控制\n- 如果服务器挂了，则集中式的代码好多将永久性损坏，而分布式只要有一台电脑是好的，大部分代码是可以找回来的\n\n## git安装\n### windows电脑安装\n[git安装](http://jingyan.baidu.com/article/90895e0fb3495f64ed6b0b50.html)\n### mac电脑\nmac电脑内置了git软件\n\n### git bash使用注意事项\n- 打开方式：在当前项目文件夹中，右键 --\u003e git bash打开\n- 可以按住ctrl+鼠标滚轮进行放大缩小 \n\n## 配置用户信息\n为了标识出每一个小的修改是谁修改的，我们需要在使用git之前做一些配置\n```\n$ git config --global user.name \"zhengwei1949\"\n$ git config --global user.email zhengwei1949@qq.com\n```\n\n### 注意\n- 上面的$大家在敲命令的时候，一定不要输\n- 用户名如果没有空格隔开，不需要加双引号\n- 建议加上--global配置项，这是一个你的电脑全局性的配置，以后任何项目文件夹在初始化git的时候都不用管这个了\n\n### 查看是否设置正确\n```\ngit config user.name\n```\n\nand\n\n```\ngit config user.email\n```\n\nor\n\n```\ngit config --list\n```\n\n## 创建git项目\n```\ngit init\n```\n\n![初始化git仓库](/images/git_init.png)\n\n## 将代码提交到仓库当中\n### 工作区、暂存区、仓库\n![](/images/areas.png)\n\n### 一个文件的生命周期\n![一个文件的生命周期](/images/lifecycle.png)\n\n### 将代码提交到仓库的步骤\n1. 执行`git add a.html`\n2. 执行`git commit \"添加a.html到仓库当中\"`\n\n### 查看当前代码的状态\n```\ngit status\n```\n\n#### 如何知道是哪个状态\n- 看颜色法：红色代表处于工作区、绿色代表片于暂存区、白色代表添加到了仓库\n- 看单词\n    + untracked files --\u003e 处于工作区(新增文件)\n    + changes not staged for commited --\u003e 文件被修改，未保存到暂存区\n    + changes to be committed --\u003e 处于暂存区，尚未添加到仓库当中\n\n#### 命令简化\n- `git add .` --\u003e 添加所有处于工作区文件到暂存区\n- `git commit -a -m \"添加所有修改的文件直接从工作区到仓库\"`\n\n## git忽略文件\n把一些没有必要添加到仓库的文件在`.gitignore`当中设置一下\n\n```\n.idea\n.temp\n```\n\n## 版本回退\n\n### 理解版本\n![分支](/images/fenzhi.png)\n### 文件差异对比\n1. 以工作区为基准，如果暂存区当中添加这个文件但尚未添加到仓库，则比较的是工作区与暂存区，如果暂存区的添加到了仓库，则比较工作区与仓库\n```\ngit diff\n```\n\n2. 比较暂存区与仓库代码的区别\n```\ngit diff --cached\n```\n\n### 日志的查看\n```\ngit log\n```\n\n### 版本回退\n![版本回退图](/images/git-reset.jpg)\n![版本回退图](/images/git_reset.gif)\n```\ngit reset --hard HEAD~0 --\u003e 放弃所有的当前工作区与暂存区代码，回退到与仓库代码一致\ngit reset --hard HEAD~1 --\u003e 切换到上一次仓库代码\ngit reset --hard HEAD~2 --\u003e 切换到上上一次仓库代码\n```\n\n### 查看所有的版本号\n```\ngit reflog\n```\n### 根据版本号进行对比\n```\ngit diff 版本号1 版本号2\n```\n\n### 根据版本号进行回退\n```\ngit reset --hard 版本号\n```\n\n## 配置别名\n```\n$ git config --global alias.st status\n$ git config --global alias.ci commit\n$ git config --global alias.co checkout\n$ git config --global alias.br branch\n$ git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\"\n```\n\n## 分支\n![分支模型](/images/lr-branches-2.png)\n在版本回退里，每次提交，Git会把它们串成一条时间线，这条时间线就是一个分支。截止目前，只有一条时间线，在Git里，这条分支叫主分支，即`master`分支。HEAD严格来说不是指向提交，而是指向`master`,`master`才是指向提交的，所以`HEAD`指向的就是当前分支。\n一开始的时候，`master`分支是一条线，Git用`master`指向最新的提交，再用HEAD指向`master`,就能确定当前分支，以及当前分支的提交点。\n\n### 创建分支\n```\ngit branch 分支名\n```\n\n### 切换分支\n```\ngit checkout 分支名\n```\n\n#### 注意：\n切换分支的时候，一定要把当前的仓库的不是在仓库里面的代码提交到仓库(工作区、暂存区)\n\n### 删除分支\n```\ngit branch -d 分支名\n```\n\n### 创建并切换分支\n```\ngit checkout -b 分支名\n```\n\n## 合并分支\n```\ngit merge 分支名\n```\n\n### 如何判断出现了冲突\n```\nCONFLIT   \n```\n\n#### 冲突的原因\n两个不同的分支修改了同一个文件的同一行代码，当他们需要合并(git merge)的时候，就会有冲突\n\n#### 冲突什么情况下会出现？\n- git merge的时候 --\u003e 也就是分支进行合并的时候，对比两个文件有没有修改同一行代码\n\n### 本地模拟冲突\n#### 实验一\na分支上面没有这一行代码，b分支上多了这一行 --\u003e 不会冲突\n#### 实验二\na分支和b分支上都多了这一行，但是代码是相同的 --\u003e 不会冲突\n#### 实验三\na分支和b分支上都多了这一行，但是代码是不同的 --\u003e 冲突\n\n#### 如何解决冲突\n1. 确定我们最终要的代码\n2. 执行`git add .`\n3. 执行`git commit -m '提交信息'`\n\n## git练习\n- 可以玩下level 1就行了 [git在线练习](https://www.codeschool.com/learn/git)\n\n## github\n[使用github](http://jingyan.baidu.com/article/f7ff0bfc7181492e27bb1360.html)\n\n## github工作流\n```\ngit init\ngit add .\ngit commit -m '代码提交注释'\ngit remote add origin 仓库地址\ngit push -u origin master\n```\n\n## github配置ssh\n[配置github的ssh](http://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html)\n\n## github工作流(更通用版)\n```\ngit clone 仓库地址(或者git init + git remote add origin 仓库地址 + git pull)\ngit add .\ngit commit -m '代码提交注释'\ngit push -u origin master\n```\n\n## 推送到远程服务器的时候出现拒绝(rejected)\n\n### 本地代码能推送的前提\n- 本地的项目必须是基于远程Repository代码的基础上修改的\n\n### 提交到github被拒绝\n#### 什么情况下出现rejected\n- 本地代码很旧了，线上的代码有了最新其他的用户提交的最新的代码\n\n#### 解决的办法\n- 将远程Repository中的代码git pull拉取到本地(git pull会给我们自动做一个merge,如果出现冲突会提示)\n- 然后再进行Push，即可完成代码提交\n\n#### 远程模拟冲突\n1. 创建一个github仓库\n2. 克隆到本地\n3. 在本地创建一个新的文件\n4. 推送到服务器上面\n5. 在服务器上改代码\n6. 尝试修改本地代码，推送到服务器上面\n\n#### 如何解决rejected\n1. 执行`git pull origin master`\n2. 执行`git add .`\n3. 执行`git commit -m 'abc'`\n4. 执行`git push`\n\n## tortoiseGit的使用\n### 优点\n`git add .`,`git commit -m 'wfe'`,`git push`合并成一步 ==\u003e 右键 --\u003e git提交\n\n## git常见问题汇总\n[git常见问题汇总](https://github.com/zhengwei1949/git-tips)\n\n## git常用命令汇总\n\n命令 | 含义\n---------|----------\n git init | 初始化仓库\n git add . | 把工作区中未保存的文件保存到暂存区\n git commit -m '注释' | 把文件从暂存区提交到仓库\n git status | 查看当前仓库的状态(红色代表的工作区有代码未保存到暂存区，绿色代表有代码未提交到仓库)\n git diff | 查看工作区与暂存区、仓库代码的区别\n git diff --cached | 查看暂存区与仓库代码的区别\n git diff 版本号1 版本号2 | 对比两个版本号的区别 \n git log | 查看提交日志\n git reset --hard HEAD | 撤销当前工作区、暂存区的修改 \n git reset --hard HEAD~0 | 撤销当前工作区、暂存区的修改 \n git reset --hard HEAD~1 | 切换到上一次提交的代码状态\n git reset --hard 版本号 | 切换到某版本号的提交\n git branch 分支名 | 创建分支\n git checkout 分支名 | 切换分支\n git branch -d 分支名 | 删除分支\n git merge 分支名 | 合并分支\n git remote add origin 远程服务器地址 | 提交到远程服务器\n git push -u origin master | 简写push命令(第一次提交)\n git push | 简写push命令(以后的提交)","cover":"/images/github.jpg","link":"git总结.html","preview":"\u003cp\u003eGit是一款开源的版本控制管理工具，它以快速、高效的特点被广泛应用在项目代码的团队协作当中。GitHub是一个使用Git托管的开源代码技术社区，几乎所有我们知道的开源库(框架)都可以去GitHub上面找到相关的下载地址，使用并参与到GitHub上不仅可以帮助我们获取第一手的技术资料、了解最新的技术走向，而且还可以利用GitHub进行代码的托管和管理，对技术人员来说是一个绝佳的学习平台。本文内容将聚焦如何快速入门git和github,主要涉及到git相关概念的理解，常用命令的使用介绍,github网站的使用介绍,常见的git学习资源等\u003c/p\u003e\n","title":"git总结"},{"content":"\n\n## 原型链\n\nJavascript是面向对象的，每个实例对象都有一个\\__proto\\__属性，该属性指向它原型对象，这个实例对象的构造函数有一个原型属性prototype，与实例的\\__proto\\__属性指向同一个对象。当一个对象在查找一个属性的时，自身没有就会根据\\__proto\\__ 向它的原型进行查找，如果都没有，则向它的原型的原型继续查找，直到查到Object.prototype.\\__proto\\__为nul，这样也就形成了原型链。\n\n![原型链结构图](./images/prototype.png)","cover":"/images/wallhaven-443187.jpg","link":"原型链结构图.html","preview":"\u003cp\u003e比较详细的原型链结构图。\u003c/p\u003e\n","title":"原型链结构图"},{"content":"\n\n## Array\n\n- 如果设置某个值的索引超过了数组现有项数，数组就会自动增加到该索引值加1的长度，\n打印只能打印出已经设置过值的项，其它不存在项单独访问打印输出undefined\n\n- 数组的length属性不是只读的，可以设置，如果设置的(长度-1)小于实际项数，会把后面的项移除，访问移除的项返回undefined；\n如果设置的(长度-1)大于数组项数，访问多出部份返回undefined\n\n### 转换方法\n\ntoString() \n\n- 返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串\n\n- 实际上是数组的每一项调用toString()方法的返回值组成的字符串\n\nvalueOf()  \n\n- 返回数组\n\njoin()        \n\n- 传入一个参数，返回由数组中每个值的字符串形式拼接而成的一个以传入的参数分隔的字符串\n              \n- 不传或者传入undefined，默认分隔符为逗号，IE7及以下版本会以undefined分隔\n\n\u003e 如果数组中的某一项为null或者undefined，则调用以上方法该项会以空字符串的方式返回\n\n### 栈方法LIFO(Last-In-First-Out后进先出)\npush()        \n\n- 接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度\n\npop()         \n\n- 从数组末尾移除最后一项，减少数组的length值，然后返回移除的项\n\n### 队列方法FIFO(First-In-First-Out先进先出)\n\nshift()       \n\n- 移除数组中的第一个项并返回该项，同时将数组长度减1\n\nunshift()     \n\n- 在数组前端添加任意个项并返回新数组的长度\n\n### 重排序方法：\nreverse()     \n\n- 发转数组项的顺序\n\nsort()        \n\n- 按升序排列数组项——即最小的值位于最前面，最大的值排在最后面\n\n- 会调用每个数组项的toString()转型方法，然后比较得到的字符串(字符串比较的是在字母表中的位置，相当于用的字符串localeCompare方法，返回值是1，0，-1，所以结果往往不是正常人想要的)，以确定如何排序\n              \n- 可以传入比较函数(对于数字arr.sort(function(value1,value2){return value2-value1;}))\n\n### 操作方法\nconcat()      \n\n- 拼接数组，如果没有参数返回调用数组的副本\n\nslice()       \n\n- 传一个参数，截取从该参数索引开始到结束，返回新数组\n                          \n- 传两个参数，截取第一个参数索引开始到第二个参数索引结束，返回新数组(取不到第二个参数对应索引的元素)\n                         \n- 如果参数是负数，先与数组长度相加，再按前个方式截取\n                        \n- 如果结束位置小于起始位置，则返回空数组\n\nsplice()     【最强大的数组方法】\n              \n- 删除：删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数\n              \n- 替换：向指定位置插入任意数量的项，只需提供3个参数：起始位置、要删除的项数（从起始位置那一项开始删）和要插入的项。\n - 如果要插入多个项，可以再传入第四、第五，以至任意多个项。\n - 如果要删除的项数为0，则相当与插入\n              \n- 返回值为被删除项构成的数组\n\n### 位置方法(ECMAScript5)：\nindexOf()             \n\n- 接收两个参数：要查找的项和（可选的）表示查找起点位置的索引(会比较起点位置这一项)\n                      \n- 从头或者起点位置那一项开始往后，返回要查找的项在数组中的位置，或者在没找到的情况下返回-1\n\nlastIndexOf()         \n\n- 接收两个参数：要查找的项和（可选的）表示查找起点位置的索引(会比较起点位置这一项)\n                      \n- 从尾或者起点位置那一项开始往前，返回要查找的项在数组中的位置，或者在没找到的情况下返回-1\n\n\u003e必须是全等\"===\"才会返回\n\n### 迭代方法：\nforEach()             \n\n- 对数组中的每一项运行给定函数，没有返回值\n\nfilter()              \n\n- 对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的数组\n\nmap()                 \n\n- 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组\n\nsome()                \n\n- 对数组中的每一项运行给定函数，该函数对任意一项返回true，则返回值为true  （||）\n\nevery()               \n\n- 对数组中的每一项运行给定函数，该函数对每一项返回true，则返回值为true（\u0026\u0026）\n\u003e传参顺序都是(item,index,array) 只有jQuery的each函数是(index, item) \n\n### 归并方法：\nreduce()              \n\n- 从数组第一项开始到最后一项，迭代的开始项是数组的第二项，所以迭代的第一项是数组的第一项\nreduceRight()         \n- 从数组最后一项开始到第一项，迭代的开始项是数组的倒数第二项，所以迭代的第一项是数组的倒数第一项\n  - 这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。\n  - 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选）作为归并基础的初始值\n      - 被传入的函数都可以接受四个参数，前一个值(prev),当前值(cur)，项的索引和数组对象\n         - 这个函数返回的任何值都会作为第一个参数自动传给下一项。\n\n# String操作方法\n\u003e所有方法空字符都算\n\n### 字符方法：\ncharAt()              \n\n- 接受一个参数，返回对应字符串索引的字符\ncharCodeAt()          \n- 接受一个参数，返回对应字符串索引的字符编码\n\n### 字符串操作方法：\nconcat()              \n\n- 接受任意多个字符串参数，拼接字符串，返回新字符串，不会改变原始字符串(一般用+隐式转换代替)\n\n### ECMAScript提供\nslice()、substr()、substring()\n\n- 三个方法都可以接受1-2个参数\n- 参数不为负数：\n    - 相同点：第一个参数指定开始位置，第二个参数指定结束位置(不传默认到字符串结尾)\n    - 不同点：slice()、substring()第二个参数指的是取到该位置的前一个字符(取前不取后)\n                    substr()第二个参数指的是返回的字符串个数\n- 参数为负数：\n    - slice()方法会将传入的负值与字符串的长度相加(如果转换后第一个参数\u003e=第二个参数，则返回空字符串)\n    - substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0(如果第二个参数是负值，必然返回空字符串)\n\n    - substring()方法会把所有负值参数都转换为0 (substring()会将传入的较小的数作为开始位置)\n\n### 字符串位置方法(同数组位置方法)：\nindexOf()\nlastIndexOf()\n\n### trim方法(ECMAScript5)：\ntrim()       \n\n- 删除前置和后置的所有空格,返回一个新字符串，原始字符串不改变\n\n### 字符串大小写转换方法\ntoLowerCase()           \n\n- 转小写\n\ntoUpperCase()           \n\n- 转大写\n\ntoLocaleLowerCase()     \n\n- 针对不同地区转小写\n\ntoLocaleUpperCase()     \n\n- 针对不同地区转大写\n\n### 字符串的模式匹配方法\nmatch()     \n\n- 只接受一个参数，要么是正则表达式，要么是一个对象     \n- 数组的第一项是与整个模式匹配的字符串(第一个匹配成功的)，之后的每一项(如果有)保存着与正则表达式中的捕获组匹配的字符串\n\nsearch()    \n\n- 只接受一个参数，要么是正则表达式，要么是一个对象\n- 返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1\n\nreplace()  \n\n- 接受两个参数：第一个参数可以是一个RegExp对象或者一个字符串(这个字符串不会被转换成正则表达式)，第二个参数可以是一个字符串或者一个函数\n   - 如果第一个参数是字符串，那只会替换第一个匹配的字符串\n     - 如果想要替换所有，唯一的办法是写一个正则表达式，并指定全局(g)\n- 第二个参数可以是一个函数，这个函数应该返回一个字符串表示替换的内容\n   - 在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。\n      - 在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串\n\nsplit()     \n\n- 可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中\n  - 分隔符可以是字符串，也可以是一个RegExp对象\n- 可以接受可选的第二个参数，用于指定数组的大小","cover":"/images/wallhaven-443187.jpg","link":"数组、字符串操作方法.html","preview":"\u003cp\u003e简单总结了JS中数组和字符串的操作方法。\u003c/p\u003e\n","title":"数组、字符串操作方法"},{"content":"\n\n## HTML5\n- [Html5的概念](#Html5的概念)\n- [Html5的兼容性（浏览器之间的兼容）](#Html5的兼容性（浏览器之间的兼容）)\n- [html5的骨架](#html5的骨架)\n- [html5新增的标签](#html5新增的标签)\n    - [新增标签兼容问题](#新增标签兼容问题)\n- [html5新增的智能表单](#html5新增的智能表单)\n    - [输入类型](#输入类型)\n    - [表单元素](#表单元素)\n    - [表单属性](#表单属性)\n    - [智能感应](#智能感应)\n- [多媒体](#多媒体)\n- [JS获取元素的新方式 （兼容8，以上包括8）](#JS获取元素的新方式 （重点，兼容8，以上包括8）)\n- [JS类名操作  （移动端常用，兼容：10以上，包括10）](#JS类名操作  （移动端常用，兼容：10以上，包括10）)\n- [自定义属性](#自定义属性)\n\n\n### Html5的概念\n\n* HTML5并不仅仅只是作为HTML标记语言的一个最新版本，更重要的是它制定了Web应用开发的一系列标准，成为第一个将Web做为应用开发平台的HTML语言。\n\n* HTML5定义了一系列新元素，如新语义标签、智能表单、多媒体标签等，可以帮助开发者创建丰富的互联网应用，还提供了一系列Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用，甚至结合Canvas我们可开发网页版游戏，同时结合CSS3的过渡、转换、动画等特性，可以极大的增强用户体验，提升开发功能的可应用性。\n\n* 我们日常讨论的H5其实是一个泛称，它指的是由HTML5 + CSS3 + Javascript等技术组合而成的一个应用开发平台。\n\n### Html5的兼容性（浏览器之间的兼容）\n\n* 并不是所有的html5都是IE9就兼容的，有一些属性是需要IE10，等更高级的浏览器才能兼容，不过html5更多运用在移动端方面，因为移动端搭载的浏览器都比较高级！后面的css3相对来说应用的会更广泛一些\n    \n### html5的骨架\n\u003ehtml5骨架是没有兼容性问题\n\n```\n1  \u003c!DOCTYPE html\u003e\n2  \u003chtml lang=\"en\"\u003e\n3  \u003chead\u003e\n4  \t\u003cmeta charset=\"UTF-8\"\u003e\n5  \t\u003ctitle\u003eDocument\u003c/title\u003e\n6  \u003c/head\u003e\n7  \u003cbody\u003e\n8  \u003c/body\u003e\n9  \u003c/html\u003e\n```\n\n### html5新增的标签\n1. 新增的6大结构标签：\n（1）header  （2）nav （3）section （4）aside （5）article （6）footer\n\n    ```\n    //\u003c!DOCTYPE\u003e 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。\n    \u003c!DOCTYPE html\u003e\n    \u003chtml lang=\"en\"\u003e\n    \u003chead\u003e\n        \u003cmeta charset=\"UTF-8\"\u003e\n        \u003ctitle\u003eDocument\u003c/title\u003e\n    \u003c/head\u003e\n    \u003cbody\u003e\n        //\u003cheader\u003e 标签定义文档的页眉（介绍信息）。\n        \u003cheader\u003e\n            //\u003cnav\u003e 标签定义导航链接的部分。\n            \u003cnav\u003e\u003c/nav\u003e\n        \u003c/header\u003e\n        //在一个文档中，不能出现一个以上的 \u003cmain\u003e 元素。\n        //\u003cmain\u003e 元素不能是以下元素的后代：\u003carticle\u003e、\u003caside\u003e、\u003cfooter\u003e、\u003cheader\u003e 或 \u003cnav\u003e\n        \u003cmain\u003e\n            //\u003csection\u003e 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。\n            \u003csection\u003e\n                //\u003caside\u003e 标签定义其所处内容之外的内容。\n                //aside 的内容应该与附近的内容相关。\n                \u003caside\u003e\u003c/aside\u003e\n                //\u003carticle\u003e 标签规定独立的自包含内容。\n                //一篇文章应有其自身的意义，应该有可能独立于站点的其余部分对其进行分发。\n                \u003carticle\u003e\u003c/article\u003e\n            \u003c/section\u003e\n        \u003c/main\u003e\n        \u003cfooter\u003e\u003c/footer\u003e\n    \u003c/body\u003e\n    \u003c/html\u003e\n    ```\n2. 新增标签兼容问题\n\n- 利用document.creatElement()去创建html5的新标签，同时设置成块元素（相对麻烦）\n\n    ```\n    \u003c!--[if lt IE 9]\u003e \n        \u003cscript type=\"text/javascript\"\u003e\n\t\t    var e = \"abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video\".split(', ');\n\t        var i= e.length;\n\t\t    while (i--){\n\t\t         document.createElement(e[i])\n\t\t    }\n\t\t\u003c/script\u003e\n    \u003c![endif]--\u003e\n    ```\n\n- 借助于第三方的JS框架 =\u003ehtml5shiv.min.js （推荐）配合IE的hack实现最佳兼容\n\n    ```\n    \u003c!--[if lt IE 9]\u003e \n  \t    \u003cscript src=\"js/html5shiv.min.js\"\u003e\u003c/script\u003e\n    \u003c![endif]--\u003e\n    ```\n\n### html5新增的智能表单\n\n#### 输入类型\n\nInput表单的type新属性值|含义|示例\n-------------|------------|-----------\ntype=\"email\"|限制用户输入必须为Ema   | \u003cinput type=\"email\"\u003e\ntype=\"url\"|限制用户输入必须为URL类型  |\u003cinput type=\"url\"\u003e\ntype=\"date\"  |自动生成一个日期控件    |\u003cinput type=\"date\"\u003e\ntype=\"time\"  |同上                  |\u003cinput type=\"time\"\u003e\ntype=\"month\" |同上                  |\u003cinput type=\"month\"\u003e\ntype=\"week\"  |同上                  |\u003cinput type=\"week\"\u003e\ntype=\"number\"|限制用户输入必须为数字  |\u003cinput type=\"number\"\u003e\ntype=\"range\" |产生一个滑动条的表单    |\u003cinput type=\"range\"\u003e\ntype=\"search\"|产生一个搜索意义的表单  |\u003cinput type=\"search\"\u003e\ntype=\"color\" |生成一个颜色选择表单    |\u003cinput type=\"color\"\u003e\n\n\u003e智能表单的兼容问题比较大，在移动端用的较多，移动端会自动调取手机本身的控件（不同手机之间会略有不同，但如果需要高度自定义，就需要用JS去写了），在企业内部的系统里面可以去使用\n\n#### 表单元素\n\n元素|含义|示例\n-----|------|----\ndatalist|数据列表|\u003cdatalist\u003e\nkeygen|生成加密字符|\u003ckeygen\u003e\noutput|输出结果|\u003coutput\u003e\nmeter|度量器|\u003cmeter\u003e\n\n#### 表单属性\n\n属性\t|用法\t|含义\n-----|-----|-----\nplaceholder\t|\u003cinput type=\"text\" placeholder=\"请输入用户名\"\u003e\t|占位符\nautofocus\t|\u003cinput type=\"text\" autofocus\u003e\t|自动获得焦点\nmultiple\t|\u003cinput type=\"file\" multiple\u003e\t|多文件上传\nautocomplete\t|\u003cinput type=\"text\" autocomplete=\"off\"\u003e\t|自动完成\nform\t|\u003cinput type=\"text\" form=\"某表单ID\"\u003e\nnovalidate\t|\u003cform novalidate\u003e\u003c/form\u003e\t|关闭验证\nrequired\t|\u003cinput type=\"text\" required\u003e\t|必填项\npattern\t|\u003cinput type=\"text\" pattern=\"\\d\"\u003e\t|自定义验证\n\t\n\n#### 智能感应\n\n* 利用表单的list =“datalist的id值”与datalist这个标签取得联系实现\n\n```\n    \u003cinput type = \"text\" list = 'foodList'\u003e\n\t\u003cdatalist id = 'foodList'\u003e\n\t\t\u003coption value = \"西葫芦\"\u003e\n\t\t\u003coption value = \"牛肉\"\u003e\n\t\u003c/datalist\u003e\n```\n\n### 多媒体\n* 直到现在，我们的视频依旧采用第三方的网站播放视频，并且需要借助于flash技术\n在html5中，我们只需要借助于video这个标签来实现视频的播放\n\n    ```\n    \u003cvideo  controls\u003e\n\t\t\u003csource src=\"movie/....ogg\"\u003e\n\t\t\u003csource src=\"movie/....mp4\"\u003e\n\t\u003c/video\u003e\n    ```\n\n* 可以通过附加属性可以更友好控制视频的播放，如：\n    - autoplay 自动播放\n    - controls 是否显不默认播放控件\n    - loop 循环播放\n    - poster 在视频没有播放的时候的预览图片\n\n* 视频的API：（注：是JS的，JQ去使用需要转化对象）\n        - play(） 控制视频播放\n        - pause() 控制视频暂停\n        - load()  重新加载视频或者音频\n音频：audio的用法与视频一模一样\n\n\n\u003e在开发中，如果是一个相对比较大的视频建议还是利用第三方的网站去实现视频播放，一些小的广告类的小视频可以用video，一些宣传类的手机站（特效颇多）我们可以做成一个小的video\n\n### JS获取元素的新方式 （兼容8，以上包括8）\n1. document.querySelector('selector') 通过类似CSS选择器获取元素，符合匹配条件的第1个元素。可以传入复合选择器（如：.box li, .box \u003e li input[type=’button’]）等\n2. document.querySelectorAll('selector') 通过CSS选择器获取元素，以类数组形式存在。可以传入复合选择器（如：.box li, .box \u003e li input[type=’button’]）等，所以用for去操作整个类数组\n\n### JS类名操作  （移动端常用，兼容：10以上，包括10）\n\n1. Node.classList.add('class') 添加class\n2. Node.classList.remove('class') 移除class\n3. Node.classList.toggle('class') 切换class，有则移除，无则添加\n4. Node.classList.contains('class') 检测是否存在class\n\n### 自定义属性\n* 在HTML5中我们可以自定义属性，其格式如下data-*=\"\"，例如:data-info=\"我是自定义属性\"，通过Node.dataset['info'] 我们便可以获取到自定义的属性值。\n* Node.dataset是以对象形式存在的\n* 当我们如下格式设置时，则需要以驼峰格式才能正确获取\ndata-my-name=\"itcast\"，获取Node.dataset['myName']\n* 在JQ中，可以通过data方法去获取标签的data属性的值\n\n\n\n\n\n","cover":"/images/H5.jpg","link":"html5.html","preview":"\u003cp\u003eHTML5。\u003c/p\u003e\n","title":"HTML5"}]